{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"react\"","webpack:///external \"lodash\"","webpack:///./datasource-zabbix/utils.ts","webpack:///./datasource-zabbix/constants.ts","webpack:///external \"@grafana/ui\"","webpack:///external \"@grafana/data\"","webpack:///external \"emotion\"","webpack:///./datasource-zabbix/types.ts","webpack:///external \"@grafana/runtime\"","webpack:///external \"moment\"","webpack:///../node_modules/semver/classes/semver.js","webpack:///./panel-triggers/utils.ts","webpack:///external \"app/core/utils/datemath\"","webpack:///external \"jquery\"","webpack:///../node_modules/semver/functions/compare.js","webpack:///../node_modules/semver/classes/range.js","webpack:///external \"app/plugins/sdk\"","webpack:///./panel-triggers/migrations.ts","webpack:///../node_modules/semver/internal/re.js","webpack:///../node_modules/semver/functions/parse.js","webpack:///../node_modules/semver/internal/constants.js","webpack:///../node_modules/semver/internal/debug.js","webpack:///../node_modules/semver/functions/gt.js","webpack:///../node_modules/semver/classes/comparator.js","webpack:///../node_modules/semver/functions/satisfies.js","webpack:///external \"app/core/core_module\"","webpack:///../node_modules/semver/internal/identifiers.js","webpack:///../node_modules/semver/functions/eq.js","webpack:///../node_modules/semver/functions/compare-build.js","webpack:///../node_modules/semver/functions/lt.js","webpack:///../node_modules/semver/functions/gte.js","webpack:///../node_modules/semver/functions/lte.js","webpack:///../node_modules/semver/ranges/outside.js","webpack:///external \"app/core/core\"","webpack:///external \"app/core/table_model\"","webpack:///external \"app/core/utils/kbn\"","webpack:///../node_modules/semver/functions/neq.js","webpack:///../node_modules/semver/functions/cmp.js","webpack:///external \"app/core/config\"","webpack:///../node_modules/semver/index.js","webpack:///external \"angular\"","webpack:///../node_modules/semver/functions/valid.js","webpack:///../node_modules/semver/functions/clean.js","webpack:///../node_modules/semver/functions/inc.js","webpack:///../node_modules/semver/functions/diff.js","webpack:///../node_modules/semver/functions/major.js","webpack:///../node_modules/semver/functions/minor.js","webpack:///../node_modules/semver/functions/patch.js","webpack:///../node_modules/semver/functions/prerelease.js","webpack:///../node_modules/semver/functions/rcompare.js","webpack:///../node_modules/semver/functions/compare-loose.js","webpack:///../node_modules/semver/functions/sort.js","webpack:///../node_modules/semver/functions/rsort.js","webpack:///../node_modules/semver/functions/coerce.js","webpack:///../node_modules/semver/ranges/to-comparators.js","webpack:///../node_modules/semver/ranges/max-satisfying.js","webpack:///../node_modules/semver/ranges/min-satisfying.js","webpack:///../node_modules/semver/ranges/min-version.js","webpack:///../node_modules/semver/ranges/valid.js","webpack:///../node_modules/semver/ranges/gtr.js","webpack:///../node_modules/semver/ranges/ltr.js","webpack:///../node_modules/semver/ranges/intersects.js","webpack:///../node_modules/semver/ranges/simplify.js","webpack:///../node_modules/semver/ranges/subset.js","webpack:///./datasource-zabbix/migrations.ts","webpack:///./datasource-zabbix/metricFunctions.ts","webpack:///./datasource-zabbix/timeseries.ts","webpack:///./datasource-zabbix/dataProcessor.ts","webpack:///./datasource-zabbix/responseHandler.ts","webpack:///./datasource-zabbix/problemsHandler.ts","webpack:///./datasource-zabbix/zabbix/proxy/cachingProxy.ts","webpack:///./datasource-zabbix/zabbix/connectors/dbConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/zabbix_api/zabbixAPIConnector.ts","webpack:///./datasource-zabbix/zabbix/connectors/sql/mysql.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/postgres.js","webpack:///./datasource-zabbix/zabbix/connectors/sql/sqlConnector.js","webpack:///./datasource-zabbix/zabbix/connectors/influxdb/influxdbConnector.js","webpack:///./datasource-zabbix/zabbix/zabbix.ts","webpack:///./datasource-zabbix/datasource.ts","webpack:///./datasource-zabbix/components/ZabbixInput.tsx","webpack:///./datasource-zabbix/query.controller.ts","webpack:///./datasource-zabbix/components/VariableQueryEditor.tsx","webpack:///./datasource-zabbix/components/ConfigEditor.tsx","webpack:///./datasource-zabbix/add-metric-function.directive.js","webpack:///./datasource-zabbix/react2angular.ts","webpack:///./datasource-zabbix/components/FunctionEditorControls.tsx","webpack:///./datasource-zabbix/components/FunctionEditor.tsx","webpack:///./datasource-zabbix/metric-function-editor.directive.ts","webpack:///./datasource-zabbix/module.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","variableRegex","expandItemName","paramStr","params","quoted","in_array","param","key_params_str","substring","indexOf","lastIndexOf","key_params","forEach","symbol","push","length","replace","expandItems","items","item","key_","MACRO_PATTERN","containsMacro","itemName","test","replaceMacro","macros","isTriggerItem","url","item_macros","match","macro","host_macros","filter","hostid","hosts","h","macro_def","find","macro_value","macro_regex","RegExp","escapeMacro","parseLegacyVariableQuery","query","queryType","parts","each","split","isContainsBraces","result","map","part","trim","splitTemplateQuery","template","zipObject","app","Group","Host","Application","Item","group","host","application","regexPattern","isRegex","str","isTemplateVariable","templateVariables","variables","variable","includes","getRangeScopedVars","range","msRange","to","diff","from","sRange","Math","round","regularRange","secondsToHms","__range_ms","text","__range_s","__range","__range_series","buildRegex","matches","pattern","flags","undefined","escapeRegex","parseItemInterval","interval","normalizedInterval","parsedInterval","exec","normalizeZabbixInterval","parseInterval","momentInterval","duration","Number","valueOf","parseTimeShiftInterval","formatAcknowledges","acknowledges","ack","unix","clock","format","alias","surname","message","concat","sequence","funcsArray","this","compactQuery","getArrayDepth","a","level","elem","isArray","isNumeric","isNaN","parseFloat","isFinite","parseTags","tagStr","tags","tag","tagParts","mustArray","unitsMap","knownGrafanaUnits","units","submenu","unit","getKnownGrafanaUnits","convertZabbixUnit","zabbixUnit","getValueMapping","valueMappings","valuemapid","mapping","mappings","id","type","ValueToText","newvalue","isProblemsDataFrame","data","fields","other","config","custom","ZABBIX_PROBLEMS_PANEL_ID","DATAPOINT_VALUE","DATAPOINT_TS","MODE_METRICS","MODE_ITSERVICE","MODE_TEXT","MODE_ITEMID","MODE_TRIGGERS","MODE_PROBLEMS","ZBX_ACK_ACTION_NONE","ZBX_ACK_ACTION_CLOSE","ZBX_ACK_ACTION_ACK","ZBX_ACK_ACTION_ADD_MESSAGE","ZBX_ACK_ACTION_CHANGE_SEVERITY","TRIGGER_SEVERITY","val","MIN_SLA_INTERVAL","RANGE_VARIABLE_VALUE","DEFAULT_ZABBIX_PROBLEMS_LIMIT","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__6__","__WEBPACK_EXTERNAL_MODULE__7__","VariableQueryTypes","ShowProblemTypes","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__11__","debug","require","MAX_LENGTH","MAX_SAFE_INTEGER","re","compareIdentifiers","SemVer","version","options","loose","includePrerelease","TypeError","LOOSE","FULL","raw","major","minor","patch","prerelease","num","build","join","compareMain","comparePre","b","release","identifier","inc","Error","isNewProblem","problem","highlightNewerThan","highlightIntervalMs","Date","now","timestamp","e","formatLastChange","lastchangeUnix","customFormat","getNextRefIdChar","queries","refId","every","renderUrl","path","rbracket","add","buildParams","keys","obj","toString","k","v","encodeURIComponentAsAngularJS","prefix","len","String","pctEncodeSpaces","encodeURIComponent","__WEBPACK_EXTERNAL_MODULE__14__","__WEBPACK_EXTERNAL_MODULE__15__","compare","Range","Comparator","set","parseRange","comps","hr","HYPHENRANGELOOSE","HYPHENRANGE","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","compRe","COMPARATORLOOSE","COMPARATOR","comp","parseComparator","replaceGTE0","some","thisComparators","isSatisfiable","rangeComparators","thisComparator","rangeComparator","intersects","er","testSet","comparators","remainingComparators","slice","testComparator","pop","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","toLowerCase","replaceTilde","TILDELOOSE","TILDE","_","M","pr","ret","replaceCaret","CARETLOOSE","CARET","z","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","tb","semver","ANY","allowed","__WEBPACK_EXTERNAL_MODULE__18__","CURRENT_SCHEMA_VERSION","migratePanelSchema","panel","targets","target","trigger","isDefaultTarget","isDefaultPanel","datasource","datasources","triggers","isEmpty","isEmptyPanel","schemaVersion","getSchemaVersion","lastChangeField","infoField","scroll","hideHostsInMaintenance","defaultsDeep","proxy","showEvents","updatedTargets","targetKey","isEmptyTarget","isInvalidTarget","showProblems","migrateShowEvents","migrateOptions","defaults","hostsInMaintenance","sortProblems","sortTriggersBy","showTriggers","acknowledged","limit","minSeverity","Problems","History","MAX_SAFE_COMPONENT_LENGTH","src","R","createToken","isGlobal","index","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCE","LONETILDE","LONECARET","SEMVER_SPEC_VERSION","process","env","NODE_DEBUG","args","console","error","parse","operator","cmp","sameDirectionIncreasing","sameDirectionDecreasing","sameSemVer","differentDirectionsInclusive","oppositeDirectionsLessThan","oppositeDirectionsGreaterThan","__WEBPACK_EXTERNAL_MODULE__29__","numeric","anum","bnum","rcompareIdentifiers","versionA","versionB","compareBuild","satisfies","gt","lt","lte","gte","hilo","gtfn","ltefn","ltfn","ecomp","high","low","comparator","__WEBPACK_EXTERNAL_MODULE__37__","__WEBPACK_EXTERNAL_MODULE__38__","__WEBPACK_EXTERNAL_MODULE__39__","eq","neq","op","__WEBPACK_EXTERNAL_MODULE__43__","internalRe","tokens","valid","clean","rcompare","compareLoose","sort","rsort","coerce","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","__WEBPACK_EXTERNAL_MODULE__45__","version1","version2","v1","v2","hasPre","defaultResult","parsed","list","rtl","next","COERCERTL","lastIndex","versions","max","maxSV","rangeObj","min","minSV","minver","compver","r1","r2","prev","ranges","simplified","original","simpleSubset","sub","dom","gtltComp","eqSet","Set","higherGT","lowerLT","size","hasDomLT","hasDomGT","sawNonNull","OUTER","simpleSub","simpleDom","isSub","f","def","jsonData","dbConnection","funcDef","func","paramType","strValue","datapoints","point","ms_interval","series","left","right","time_to","timeWindow","groupBy","interpolated_timeseries","j","ema","values","values_non_null","partial","aggregateWrapper","setAlias","dp","itemid","scopedVars","extractedValue","addHostName","convertText","table","addColumn","valueFiled","firstTs","minTimestamp","toArray","triggerFilter","cacheOptions","self","cache","funcName","promises","promiseKeeper","hash","datasourceId","datasourceName","datasourceTypeId","datasourceTypeName","DBConnector","then","ds","meta","convertGrafanaTSResponse","history","methodName","code","grafanaSeries","compact","DEFAULT_QUERY_LIMIT","HISTORY_TO_TABLE_MAP","TREND_TO_TABLE_MAP","consolidateByFunc","consolidateByTrendColumns","requestOptions","getVersionPromise","action","applicationids","timeRange","historyQuery","trendsQuery","itemids","timeFrom","timeTill","intervalSec","testQuery","ITEMID_FORMAT","time_expression","mysql","sqlDialect","postgres","invokeSQLQuery","intervalMs","consolidateBy","numOfIntervals","grouped_items","value_type","results","valueColumn","dbConnector","rawSql","maxDataPoints","method","retentionPolicy","Promise","reject","buildHistoryQuery","invokeInfluxDBQuery","handleInfluxHistoryResponse","influxSeries","points","measurement","where_clause","itemidsWhere","cachingProxy","proxifyWithCache","initDBConnector","testDataSource","filters","apps","getAllHosts","groupFilter","getAllApps","getApps","appsResponse","hostids","getAllItems","getItemValues","getProblems","hostFilter","getProblemsHistory","getHistoryTS","getTrends","finded","instanceSettings","trends","timeseries","bindFunctionDefs","functions","itservices","replaceTemplateVars","severities","problems","zabbix","templateSrv","variableExists","annotation","annotationTags","metricObj","replacedTarget","getMetricNames","metrics","unshift","utils","move","aliasFunc","renderQueryOptionsText","optionsMap","optionValue","inputClass","styles","label","state","className","$compile","$scope","functionMenu","$button","click","$","buttonTemplate","appendTo","$input","attr","typeahead","minLength","updater","keyup","blur","setTimeout","show","removeClass","onClick","updatePopperPosition","$comma","$link","paramIndex","defParams","ctrl","moveFunction","secureJsonData"],"mappings":"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","file":"datasource-zabbix/module.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 75);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","import _ from 'lodash';\nimport moment from 'moment';\nimport * as c from './constants';\nimport { VariableQuery, VariableQueryTypes } from './types';\nimport { MappingType, ValueMapping, getValueFormats, DataFrame, FieldType, rangeUtil } from '@grafana/data';\n\n/*\n * This regex matches 3 types of variable reference with an optional format specifier\n * \\$(\\w+)                          $var1\n * \\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]    [[var2]] or [[var2:fmt2]]\n * \\${(\\w+)(?::(\\w+))?}             ${var3} or ${var3:fmt3}\n */\nexport const variableRegex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)(?::(\\w+))?\\]\\]|\\${(\\w+)(?:\\.([^:^\\}]+))?(?::(\\w+))?}/g;\n\n/**\n * Expand Zabbix item name\n *\n * @param  {string} name item name, ie \"CPU $2 time\"\n * @param  {string} key  item key, ie system.cpu.util[,system,avg1]\n * @return {string}      expanded name, ie \"CPU system time\"\n */\nexport function expandItemName(name: string, key: string): string {\n\n  // extract params from key:\n  // \"system.cpu.util[,system,avg1]\" --> [\"\", \"system\", \"avg1\"]\n  const key_params_str = key.substring(key.indexOf('[') + 1, key.lastIndexOf(']'));\n  const key_params = splitKeyParams(key_params_str);\n\n  // replace item parameters\n  for (let i = key_params.length; i >= 1; i--) {\n    name = name.replace('$' + i, key_params[i - 1]);\n  }\n  return name;\n}\n\nexport function expandItems(items) {\n  _.forEach(items, item => {\n    item.item = item.name;\n    item.name = expandItemName(item.item, item.key_);\n    return item;\n  });\n  return items;\n}\n\nfunction splitKeyParams(paramStr) {\n  const params = [];\n  let quoted = false;\n  let in_array = false;\n  const split_symbol = ',';\n  let param = '';\n\n  _.forEach(paramStr, symbol => {\n    if (symbol === '\"' && in_array) {\n      param += symbol;\n    } else if (symbol === '\"' && quoted) {\n      quoted = false;\n    } else if (symbol === '\"' && !quoted) {\n      quoted = true;\n    } else if (symbol === '[' && !quoted) {\n      in_array  = true;\n    } else if (symbol === ']' && !quoted) {\n      in_array = false;\n    } else if (symbol === split_symbol && !quoted && !in_array) {\n      params.push(param);\n      param = '';\n    } else {\n      param += symbol;\n    }\n  });\n\n  params.push(param);\n  return params;\n}\n\nconst MACRO_PATTERN = /{\\$[A-Z0-9_\\.]+}/g;\n\nexport function containsMacro(itemName) {\n  return MACRO_PATTERN.test(itemName);\n}\n\nexport function replaceMacro(item, macros, isTriggerItem?) {\n  let itemName = isTriggerItem ? item.url : item.name;\n  const item_macros = itemName.match(MACRO_PATTERN);\n  _.forEach(item_macros, macro => {\n    const host_macros = _.filter(macros, m => {\n      if (m.hostid) {\n        if (isTriggerItem) {\n          // Trigger item can have multiple hosts\n          // Check all trigger host ids against macro host id\n          let hostIdFound = false;\n          _.forEach(item.hosts, h => {\n            if (h.hostid === m.hostid) {\n              hostIdFound = true;\n            }\n          });\n          return hostIdFound;\n        } else {\n          // Check app host id against macro host id\n          return m.hostid === item.hostid;\n        }\n      } else {\n        // Add global macros\n        return true;\n      }\n    });\n\n    const macro_def = _.find(host_macros, { macro: macro });\n    if (macro_def && macro_def.value) {\n      const macro_value = macro_def.value;\n      const macro_regex = new RegExp(escapeMacro(macro));\n      itemName = itemName.replace(macro_regex, macro_value);\n    }\n  });\n\n  return itemName;\n}\n\nfunction escapeMacro(macro) {\n  macro = macro.replace(/\\$/, '\\\\\\$');\n  return macro;\n}\n\nexport function parseLegacyVariableQuery(query: string): VariableQuery {\n  let queryType: VariableQueryTypes;\n  const parts = [];\n\n  // Split query. Query structure: group.host.app.item\n  _.each(splitTemplateQuery(query), part => {\n    // Replace wildcard to regex\n    if (part === '*') {\n      part = '/.*/';\n    }\n    parts.push(part);\n  });\n  const template = _.zipObject(['group', 'host', 'app', 'item'], parts);\n\n  if (parts.length === 4 && template.app === '/.*/') {\n    // Search for all items, even it's not belong to any application\n    template.app = '';\n  }\n\n  switch (parts.length) {\n    case 1:\n      queryType = VariableQueryTypes.Group;\n      break;\n    case 2:\n      queryType = VariableQueryTypes.Host;\n      break;\n    case 3:\n      queryType = VariableQueryTypes.Application;\n      break;\n    case 4:\n      queryType = VariableQueryTypes.Item;\n      break;\n  }\n\n  const variableQuery: VariableQuery = {\n    queryType,\n    group: template.group || '',\n    host: template.host || '',\n    application: template.app || '',\n    item: template.item || '',\n  };\n\n  return variableQuery;\n}\n\n/**\n * Split template query to parts of zabbix entities\n * group.host.app.item -> [group, host, app, item]\n * {group}{host.com} -> [group, host.com]\n */\nexport function splitTemplateQuery(query) {\n  const splitPattern = /\\{[^\\{\\}]*\\}|\\{\\/.*\\/\\}/g;\n  let split;\n\n  if (isContainsBraces(query)) {\n    const result = query.match(splitPattern);\n    split = _.map(result, part => {\n      return _.trim(part, '{}');\n    });\n  } else {\n    split = query.split('.');\n  }\n\n  return split;\n}\n\nfunction isContainsBraces(query) {\n  const bracesPattern = /^\\{.+\\}$/;\n  return bracesPattern.test(query);\n}\n\n// Pattern for testing regex\nexport const regexPattern = /^\\/(.*)\\/([gmi]*)$/m;\n\nexport function isRegex(str) {\n  return regexPattern.test(str);\n}\n\nexport function isTemplateVariable(str, templateVariables) {\n  const variablePattern = /^\\$\\w+/;\n  if (variablePattern.test(str)) {\n    const variables = _.map(templateVariables, variable => {\n      return '$' + variable.name;\n    });\n    return _.includes(variables, str);\n  } else {\n    return false;\n  }\n}\n\nexport function getRangeScopedVars(range) {\n  const msRange = range.to.diff(range.from);\n  const sRange = Math.round(msRange / 1000);\n  const regularRange = rangeUtil.secondsToHms(msRange / 1000);\n  return {\n    __range_ms: { text: msRange, value: msRange },\n    __range_s: { text: sRange, value: sRange },\n    __range: { text: regularRange, value: regularRange },\n    __range_series: {text: c.RANGE_VARIABLE_VALUE, value: c.RANGE_VARIABLE_VALUE},\n  };\n}\n\nexport function buildRegex(str) {\n  const matches = str.match(regexPattern);\n  const pattern = matches[1];\n  const flags = matches[2] !== \"\" ? matches[2] : undefined;\n  return new RegExp(pattern, flags);\n}\n\n// Need for template variables replace\n// From Grafana's templateSrv.js\nexport function escapeRegex(value) {\n  return value.replace(/[\\\\^$*+?.()|[\\]{}\\/]/g, '\\\\$&');\n}\n\n/**\n * Parses Zabbix item update interval. Returns 0 in case of custom intervals.\n */\nexport function parseItemInterval(interval: string): number {\n  const normalizedInterval = normalizeZabbixInterval(interval);\n  if (normalizedInterval) {\n    return parseInterval(normalizedInterval);\n  }\n  return 0;\n}\n\nexport function normalizeZabbixInterval(interval: string): string {\n  const intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)?/g;\n  const parsedInterval = intervalPattern.exec(interval);\n  if (!parsedInterval || !interval || (parsedInterval.length > 2 && !parsedInterval[2])) {\n    return '';\n  }\n  return parsedInterval[1] + (parsedInterval.length > 2 ? parsedInterval[2] : 's');\n}\n\nexport function parseInterval(interval: string): number {\n  const intervalPattern = /(^[\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  const duration = moment.duration(Number(momentInterval[1]), momentInterval[2]);\n  return (duration.valueOf() as number);\n}\n\nexport function parseTimeShiftInterval(interval) {\n  const intervalPattern = /^([\\+\\-]*)([\\d]+)(y|M|w|d|h|m|s)/g;\n  const momentInterval: any[] = intervalPattern.exec(interval);\n  let duration: any = 0;\n\n  if (momentInterval[1] === '+') {\n    duration = 0 - (moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf() as any);\n  } else {\n    duration = moment.duration(Number(momentInterval[2]), momentInterval[3]).valueOf();\n  }\n\n  return duration;\n}\n\n/**\n * Format acknowledges.\n *\n * @param  {array} acknowledges array of Zabbix acknowledge objects\n * @return {string} HTML-formatted table\n */\nexport function formatAcknowledges(acknowledges) {\n  if (acknowledges.length) {\n    let formatted_acknowledges = '<br><br>Acknowledges:<br><table><tr><td><b>Time</b></td>'\n      + '<td><b>User</b></td><td><b>Comments</b></td></tr>';\n    _.each(_.map(acknowledges, ack => {\n      const timestamp = moment.unix(ack.clock);\n      return '<tr><td><i>' + timestamp.format(\"DD MMM YYYY HH:mm:ss\") + '</i></td><td>' + ack.alias\n        + ' (' + ack.name + ' ' + ack.surname + ')' + '</td><td>' + ack.message + '</td></tr>';\n    }), ack => {\n      formatted_acknowledges = formatted_acknowledges.concat(ack);\n    });\n    formatted_acknowledges = formatted_acknowledges.concat('</table>');\n    return formatted_acknowledges;\n  } else {\n    return '';\n  }\n}\n\nexport function convertToZabbixAPIUrl(url) {\n  const zabbixAPIUrlPattern = /.*api_jsonrpc.php$/;\n  const trimSlashPattern = /(.*?)[\\/]*$/;\n  if (url.match(zabbixAPIUrlPattern)) {\n    return url;\n  } else {\n    return url.replace(trimSlashPattern, \"$1\");\n  }\n}\n\n/**\n * Wrap function to prevent multiple calls\n * when waiting for result.\n */\nexport function callOnce(func, promiseKeeper) {\n  return function() {\n    if (!promiseKeeper) {\n      promiseKeeper = Promise.resolve(\n        func.apply(this, arguments)\n        .then(result => {\n          promiseKeeper = null;\n          return result;\n        }).catch(err => {\n          promiseKeeper = null;\n          throw err;\n        })\n      );\n    }\n    return promiseKeeper;\n  };\n}\n\n/**\n * Apply function one by one: `sequence([a(), b(), c()]) = c(b(a()))`\n * @param {*} funcsArray functions to apply\n */\nexport function sequence(funcsArray) {\n  return function(result) {\n    for (let i = 0; i < funcsArray.length; i++) {\n      result = funcsArray[i].call(this, result);\n    }\n    return result;\n  };\n}\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport function isValidVersion(version) {\n  return versionPattern.exec(version);\n}\n\nexport function parseVersion(version: string) {\n  const match = versionPattern.exec(version);\n  if (!match) {\n    return null;\n  }\n  const major = Number(match[1]);\n  const minor = Number(match[2] || 0);\n  const patch = Number(match[3] || 0);\n  const meta = match[4];\n  return { major, minor, patch, meta };\n}\n\n/**\n * Replaces any space-like symbols (tabs, new lines, spaces) by single whitespace.\n */\nexport function compactQuery(query) {\n  return query.replace(/\\s+/g, ' ').trim();\n}\n\nexport function getArrayDepth(a, level = 0) {\n  if (a.length === 0) {\n    return 1;\n  }\n  const elem = a[0];\n  if (_.isArray(elem)) {\n    return getArrayDepth(elem, level + 1);\n  }\n  return level + 1;\n}\n\n/**\n * Checks whether its argument represents a numeric value.\n */\nexport function isNumeric(n: any): boolean {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Parses tags string into array of {tag: value} objects\n */\nexport function parseTags(tagStr: string): any[] {\n  if (!tagStr) {\n    return [];\n  }\n\n  let tags: any[] = _.map(tagStr.split(','), (tag) => tag.trim());\n  tags = _.map(tags, (tag) => {\n    const tagParts = tag.split(':');\n    return {tag: tagParts[0].trim(), value: tagParts[1].trim()};\n  });\n  return tags;\n}\n\nexport function mustArray(result: any): any[] {\n  return result || [];\n}\n\nconst getUnitsMap = () => ({\n  '%': 'percent',\n  'b': 'decbits', // bits(SI)\n  'bps': 'bps', // bits/sec(SI)\n  'B': 'bytes', // bytes(IEC)\n  'Bps': 'binBps', // bytes/sec(IEC)\n  // 'unixtime': 'dateTimeAsSystem',\n  'uptime': 'dtdhms',\n  'qps': 'qps', // requests/sec (rps)\n  'iops': 'iops', // I/O ops/sec (iops)\n  'Hz': 'hertz', // Hertz (1/s)\n  'V': 'volt', // Volt (V)\n  'C': 'celsius', // Celsius (C)\n  'RPM': 'rotrpm', // Revolutions per minute (rpm)\n  'dBm': 'dBm', // Decibel-milliwatt (dBm)\n});\n\nconst getKnownGrafanaUnits = () => {\n  const units = {};\n  const categories = getValueFormats();\n  for (const category of categories) {\n    for (const unitDesc of category.submenu) {\n      const unit = unitDesc.value;\n      units[unit] = unit;\n    }\n  }\n  return units;\n};\n\nconst unitsMap = getUnitsMap();\nconst knownGrafanaUnits = getKnownGrafanaUnits();\n\nexport function convertZabbixUnit(zabbixUnit: string): string {\n  let unit = unitsMap[zabbixUnit];\n  if (!unit) {\n    unit = knownGrafanaUnits[zabbixUnit];\n  }\n  return unit;\n}\n\nexport function getValueMapping(item, valueMappings: any[]): ValueMapping[] | null {\n  const { valuemapid } = item;\n  const mapping = valueMappings?.find(m => m.valuemapid === valuemapid);\n  if (!mapping) {\n    return null;\n  }\n\n  return (mapping.mappings as any[]).map((m, i) => {\n    const valueMapping: ValueMapping = {\n      id: i,\n      type: MappingType.ValueToText,\n      value: m.value,\n      text: m.newvalue,\n    };\n    return valueMapping;\n  });\n}\n\nexport function isProblemsDataFrame(data: DataFrame): boolean {\n  return data.fields.length && data.fields[0].type === FieldType.other && data.fields[0].config.custom['type'] === 'problems';\n}\n","// Plugin IDs\nexport const ZABBIX_PROBLEMS_PANEL_ID = 'alexanderzobnin-zabbix-triggers-panel';\nexport const ZABBIX_DS_ID = 'alexanderzobnin-zabbix-datasource';\n\n// Data point\nexport const DATAPOINT_VALUE = 0;\nexport const DATAPOINT_TS = 1;\n\n// Editor modes\nexport const MODE_METRICS = 0;\nexport const MODE_ITSERVICE = 1;\nexport const MODE_TEXT = 2;\nexport const MODE_ITEMID = 3;\nexport const MODE_TRIGGERS = 4;\nexport const MODE_PROBLEMS = 5;\n\n// Triggers severity\nexport const SEV_NOT_CLASSIFIED = 0;\nexport const SEV_INFORMATION = 1;\nexport const SEV_WARNING = 2;\nexport const SEV_AVERAGE = 3;\nexport const SEV_HIGH = 4;\nexport const SEV_DISASTER = 5;\n\nexport const SHOW_ALL_TRIGGERS = [0, 1];\nexport const SHOW_ALL_EVENTS = [0, 1];\nexport const SHOW_OK_EVENTS = 1;\n\n// Acknowledge\nexport const ZBX_ACK_ACTION_NONE = 0;\nexport const ZBX_ACK_ACTION_CLOSE = 1;\nexport const ZBX_ACK_ACTION_ACK = 2;\nexport const ZBX_ACK_ACTION_ADD_MESSAGE = 4;\nexport const ZBX_ACK_ACTION_CHANGE_SEVERITY = 8;\n\nexport const TRIGGER_SEVERITY = [\n  {val: 0, text: 'Not classified'},\n  {val: 1, text: 'Information'},\n  {val: 2, text: 'Warning'},\n  {val: 3, text: 'Average'},\n  {val: 4, text: 'High'},\n  {val: 5, text: 'Disaster'}\n];\n\n/** Minimum interval for SLA over time (1 hour) */\nexport const MIN_SLA_INTERVAL = 3600;\n\nexport const RANGE_VARIABLE_VALUE = 'range_series';\n\nexport const DEFAULT_ZABBIX_PROBLEMS_LIMIT = 1001;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","module.exports = __WEBPACK_EXTERNAL_MODULE__6__;","module.exports = __WEBPACK_EXTERNAL_MODULE__7__;","import { SelectableValue, DataQuery, DataSourceJsonData } from \"@grafana/data\";\n\nexport interface ZabbixDSOptions extends DataSourceJsonData {\n  username: string;\n  password?: string;\n  trends: boolean;\n  trendsFrom: string;\n  trendsRange: string;\n  cacheTTL: string;\n  timeout?: string;\n  dbConnectionEnable: boolean;\n  dbConnectionDatasourceId?: number;\n  dbConnectionDatasourceName?: string;\n  dbConnectionRetentionPolicy?: string;\n  disableReadOnlyUsersAck: boolean;\n  disableDataAlignment: boolean;\n}\n\nexport interface ZabbixSecureJSONData {\n  password?: string;\n}\n\nexport interface ZabbixConnectionInfo {\n  zabbixVersion: string;\n  dbConnectorStatus: {\n    dsType: string;\n    dsName: string;\n  };\n}\n\nexport interface ZabbixConnectionTestQuery {\n  datasourceId: number;\n  queryType: string;\n}\n\nexport interface ZabbixMetricsQuery extends DataQuery {\n  triggers: { minSeverity: string; acknowledged: boolean; count: number; };\n  queryType: string;\n  datasourceId: number;\n  group: { filter: string; name?: string; };\n  host: { filter: string; name?: string; };\n  application: { filter: string; name?: string; };\n  item: { filter: string; name?: string; };\n  textFilter: string;\n  mode: number;\n  itemids: number[];\n  useCaptureGroups: boolean;\n  proxy?: { filter: string; };\n  trigger?: { filter: string; };\n  itServiceFilter?: string;\n  tags?: { filter: string; };\n  functions: ZabbixMetricFunction[];\n  options: ZabbixQueryOptions;\n  // Problems\n  showProblems?: ShowProblemTypes;\n  // Deprecated\n  hostFilter?: string;\n  itemFilter?: string;\n}\n\nexport interface ZabbixQueryOptions {\n  showDisabledItems?: boolean;\n  skipEmptyValues?: boolean;\n  disableDataAlignment?: boolean;\n  useZabbixValueMapping?: boolean;\n  // Problems options\n  minSeverity?: number;\n  sortProblems?: string;\n  acknowledged?: number;\n  hostsInMaintenance?: boolean;\n  hostProxy?: boolean;\n  limit?: number;\n  useTimeRange?: boolean;\n  severities?: number[];\n}\n\nexport interface ZabbixMetricFunction {\n  name: string;\n  params: any;\n  def: { name: string; params: any; };\n}\n\n// The paths of these files have moved around in Grafana and they don't resolve properly\n// either. Safer not to bother trying to import them just for type hinting.\n\nexport interface TemplateSrv {\n  variables: {\n    name: string;\n  };\n  highlightVariablesAsHtml(str: any): any;\n  replace(target: any, scopedVars?: any, format?: any): any;\n}\n\nexport interface DashboardSrv {\n  dash: any;\n}\n\n// Grafana types from backend code\n\ntype RowValues = object[];\ntype TimePoint = [number?, number?];\ntype TimeSeriesPoints = TimePoint[];\ntype TimeSeriesSlice = TimeSeries[];\n\ninterface TimeSeries {\n  name: string;\n  points: TimeSeriesPoints;\n  tags: { [key: string]: string };\n}\n\ninterface TableColumn {\n  text: string;\n}\n\ninterface Table {\n  columns: TableColumn[];\n  rows: RowValues[];\n}\n\ninterface QueryResult {\n  error: string;\n  refId: string;\n  meta: any;\n  series: TimeSeriesSlice[];\n  tables: Table[];\n}\n\nexport interface TSDBResponse {\n  results: { [key: string]: QueryResult };\n  message: string;\n}\n\nexport interface VariableQueryProps {\n  query: LegacyVariableQuery;\n  onChange: (query: VariableQuery, definition: string) => void;\n  datasource: any;\n  templateSrv: any;\n}\n\nexport interface VariableQueryData extends VariableQuery {\n  selectedQueryType: SelectableValue<VariableQueryTypes>;\n  legacyQuery?: string;\n}\n\nexport interface VariableQuery {\n  queryType: VariableQueryTypes;\n  group?: string;\n  host?: string;\n  application?: string;\n  item?: string;\n}\n\nexport type LegacyVariableQuery = VariableQuery | string;\n\nexport enum VariableQueryTypes {\n  Group = 'group',\n  Host = 'host',\n  Application = 'application',\n  Item = 'item',\n  ItemValues = 'itemValues',\n}\n\nexport enum ShowProblemTypes {\n  Problems = 'problems',\n  Recent = 'recent',\n  History = 'history',\n}\n\nexport interface ProblemDTO {\n  triggerid?: string;\n  eventid?: string;\n  timestamp: number;\n\n  /** Name of the trigger. */\n  name?: string;\n\n  /** Same as a name. */\n  description?: string;\n\n  /** Whether the trigger is in OK or problem state. */\n  value?: string;\n\n  datasource?: string;\n  comments?: string;\n  host?: string;\n  hostTechName?: string;\n  proxy?: string;\n  severity?: string;\n\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n\n  groups?: ZBXGroup[];\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  alerts?: ZBXAlert[];\n  tags?: ZBXTag[];\n  url?: string;\n\n  expression?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  state?: string;\n  maintenance?: boolean;\n  manual_close?: string;\n  error?: string;\n\n  showAckButton?: boolean;\n}\n\nexport interface ZBXProblem {\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  clock: string;\n  ns: string;\n  correlationid?: string;\n  datasource?: string;\n  name?: string;\n  eventid?: string;\n  maintenance?: boolean;\n  object?: string;\n  objectid?: string;\n  opdata?: any;\n  r_eventid?: string;\n  r_clock?: string;\n  r_ns?: string;\n  severity?: string;\n  showAckButton?: boolean;\n  source?: string;\n  suppressed?: string;\n  suppression_data?: any[];\n  tags?: ZBXTag[];\n  userid?: string;\n}\n\nexport interface ZBXTrigger {\n  acknowledges?: ZBXAcknowledge[];\n  showAckButton?: boolean;\n  alerts?: ZBXAlert[];\n  age?: string;\n  color?: string;\n  comments?: string;\n  correlation_mode?: string;\n  correlation_tag?: string;\n  datasource?: string;\n  description?: string;\n  error?: string;\n  expression?: string;\n  flags?: string;\n  groups?: ZBXGroup[];\n  host?: string;\n  hostTechName?: string;\n  hosts?: ZBXHost[];\n  items?: ZBXItem[];\n  lastEvent?: ZBXEvent;\n  lastchange?: string;\n  lastchangeUnix?: number;\n  maintenance?: boolean;\n  manual_close?: string;\n  priority?: string;\n  proxy?: string;\n  recovery_expression?: string;\n  recovery_mode?: string;\n  severity?: string;\n  state?: string;\n  status?: string;\n  tags?: ZBXTag[];\n  templateid?: string;\n  triggerid?: string;\n  /** Whether the trigger can generate multiple problem events. */\n  type?: string;\n  url?: string;\n  value?: string;\n}\n\nexport interface ZBXGroup {\n  groupid: string;\n  name: string;\n}\n\nexport interface ZBXHost {\n  hostid: string;\n  name: string;\n  host: string;\n  maintenance_status?: string;\n  proxy_hostid?: string;\n}\n\nexport interface ZBXItem {\n  itemid: string;\n  name: string;\n  key_: string;\n  lastvalue?: string;\n}\n\nexport interface ZBXEvent {\n  eventid: string;\n  clock: string;\n  ns?: string;\n  value?: string;\n  name?: string;\n  source?: string;\n  object?: string;\n  objectid?: string;\n  severity?: string;\n  hosts?: ZBXHost[];\n  acknowledged?: '1' | '0';\n  acknowledges?: ZBXAcknowledge[];\n  tags?: ZBXTag[];\n  suppressed?: string;\n}\n\nexport interface ZBXTag {\n  tag: string;\n  value?: string;\n}\n\nexport interface ZBXAcknowledge {\n  acknowledgeid: string;\n  eventid: string;\n  userid: string;\n  action: string;\n  clock: string;\n  time: string;\n  message?: string;\n  user: string;\n  alias: string;\n  name: string;\n  surname: string;\n}\n\nexport interface ZBXAlert {\n  eventid: string;\n  clock: string;\n  message: string;\n  error: string;\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","module.exports = __WEBPACK_EXTERNAL_MODULE__11__;","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { re, t } = require('../internal/re')\n\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier)\n        this.inc('pre', identifier)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier)\n        }\n        this.inc('pre', identifier)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre':\n        if (this.prerelease.length === 0) {\n          this.prerelease = [0]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            this.prerelease.push(0)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          if (this.prerelease[0] === identifier) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = [identifier, 0]\n            }\n          } else {\n            this.prerelease = [identifier, 0]\n          }\n        }\n        break\n\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.format()\n    this.raw = this.version\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","import _ from 'lodash';\nimport moment from 'moment';\nimport { DataQuery } from '@grafana/data';\nimport * as utils from '../datasource-zabbix/utils';\nimport { ProblemDTO } from 'datasource-zabbix/types';\n\nexport function isNewProblem(problem: ProblemDTO, highlightNewerThan: string): boolean {\n  try {\n    const highlightIntervalMs = utils.parseInterval(highlightNewerThan);\n    const durationSec = (Date.now() - problem.timestamp * 1000);\n    return durationSec < highlightIntervalMs;\n  } catch (e) {\n    return false;\n  }\n}\n\nconst DEFAULT_TIME_FORMAT = \"DD MMM YYYY HH:mm:ss\";\n\nexport function formatLastChange(lastchangeUnix: number, customFormat?: string) {\n  const timestamp = moment.unix(lastchangeUnix);\n  const format = customFormat || DEFAULT_TIME_FORMAT;\n  const lastchange = timestamp.format(format);\n  return lastchange;\n}\n\nexport const getNextRefIdChar = (queries: DataQuery[]): string => {\n  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n  return _.find(letters, refId => {\n    return _.every(queries, other => {\n      return other.refId !== refId;\n    });\n  });\n};\n\nexport type UrlQueryMap = Record<string, any>;\n\nexport function renderUrl(path: string, query: UrlQueryMap | undefined): string {\n  if (query && Object.keys(query).length > 0) {\n    path += '?' + toUrlParams(query);\n  }\n  return path;\n}\n\nfunction encodeURIComponentAsAngularJS(val: string, pctEncodeSpaces?: boolean) {\n  return encodeURIComponent(val)\n    .replace(/%25/gi, '%2525') // Double-encode % symbol to make it properly decoded in Explore\n    .replace(/%40/gi, '@')\n    .replace(/%3A/gi, ':')\n    .replace(/%24/g, '$')\n    .replace(/%2C/gi, ',')\n    .replace(/%3B/gi, ';')\n    .replace(/%20/g, pctEncodeSpaces ? '%20' : '+');\n}\n\nfunction toUrlParams(a: any) {\n  const s: any[] = [];\n  const rbracket = /\\[\\]$/;\n\n  const isArray = (obj: any) => {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  const add = (k: string, v: any) => {\n    v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n    if (typeof v !== 'boolean') {\n      s[s.length] = encodeURIComponentAsAngularJS(k, true) + '=' + encodeURIComponentAsAngularJS(v, true);\n    } else {\n      s[s.length] = encodeURIComponentAsAngularJS(k, true);\n    }\n  };\n\n  const buildParams = (prefix: string, obj: any) => {\n    let i, len, key;\n\n    if (prefix) {\n      if (isArray(obj)) {\n        for (i = 0, len = obj.length; i < len; i++) {\n          if (rbracket.test(prefix)) {\n            add(prefix, obj[i]);\n          } else {\n            buildParams(prefix, obj[i]);\n          }\n        }\n      } else if (obj && String(obj) === '[object Object]') {\n        for (key in obj) {\n          buildParams(prefix + '[' + key + ']', obj[key]);\n        }\n      } else {\n        add(prefix, obj);\n      }\n    } else if (isArray(obj)) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        add(obj[i].name, obj[i].value);\n      }\n    } else {\n      for (key in obj) {\n        buildParams(key, obj[key]);\n      }\n    }\n    return s;\n  };\n\n  return buildParams('', a).join('&');\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__14__;","module.exports = __WEBPACK_EXTERNAL_MODULE__15__;","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First, split based on boolean or ||\n    this.raw = range\n    this.set = range\n      .split(/\\s*\\|\\|\\s*/)\n      // map the range to a 2d array of comparators\n      .map(range => this.parseRange(range.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${range}`)\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => {\n        return comps.join(' ').trim()\n      })\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    const loose = this.options.loose\n    range = range.trim()\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range, re[t.COMPARATORTRIM])\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n\n    // normalize spaces\n    range = range.split(/\\s+/).join(' ')\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    return range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      .map(comp => replaceGTE0(comp, this.options))\n      // in loose mode, throw out any that are not valid comparators\n      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)\n      .map(comp => new Comparator(comp, this.options))\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\nmodule.exports = Range\n\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace\n} = require('../internal/re')\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\nconst replaceTildes = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceTilde(comp, options)\n  }).join(' ')\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\nconst replaceCarets = (comp, options) =>\n  comp.trim().split(/\\s+/).map((comp) => {\n    return replaceCaret(comp, options)\n  }).join(' ')\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map((comp) => {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<')\n        pr = '-0'\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp.trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return (`${from} ${to}`).trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__18__;","import _ from 'lodash';\nimport { getNextRefIdChar } from './utils';\nimport { ShowProblemTypes } from '../datasource-zabbix/types';\n\n// Actual schema version\nexport const CURRENT_SCHEMA_VERSION = 8;\n\nexport const getDefaultTarget = (targets?) => {\n  return {\n    group: {filter: \"\"},\n    host: {filter: \"\"},\n    application: {filter: \"\"},\n    trigger: {filter: \"\"},\n    tags: {filter: \"\"},\n    proxy: {filter: \"\"},\n    refId: getNextRefIdChar(targets),\n  };\n};\n\nexport function getDefaultTargetOptions() {\n  return {\n    hostsInMaintenance: true,\n  };\n}\n\nexport function migratePanelSchema(panel) {\n  if (isDefaultPanel(panel)) {\n    return panel;\n  }\n\n  if (isEmptyPanel(panel)) {\n    delete panel.targets;\n    return panel;\n  }\n\n  const schemaVersion = getSchemaVersion(panel);\n  // panel.schemaVersion = CURRENT_SCHEMA_VERSION;\n\n  if (schemaVersion < 2) {\n    panel.datasources = [panel.datasource];\n    panel.targets = {};\n    panel.targets[panel.datasources[0]] = panel.triggers;\n\n    // delete old props\n    delete panel.triggers;\n    delete panel.datasource;\n  }\n\n  if (schemaVersion < 3) {\n    // delete old props\n    delete panel.lastChangeField;\n    delete panel.infoField;\n    delete panel.scroll;\n    delete panel.hideHostsInMaintenance;\n  }\n\n  if (schemaVersion < 5) {\n    if (panel.targets && !_.isEmpty(panel.targets)) {\n      _.each(panel.targets, (target) => {\n        _.defaultsDeep(target, getDefaultTarget());\n      });\n    }\n  }\n\n  if (schemaVersion < 6) {\n    if (panel.showEvents && panel.showEvents.value === '1') {\n      panel.showEvents.value = 1;\n    }\n  }\n\n  if (schemaVersion < 7) {\n    const updatedTargets = [];\n    for (const targetKey in panel.targets) {\n      const target = panel.targets[targetKey];\n      if (!isEmptyTarget(target) && !isInvalidTarget(target, targetKey)) {\n        updatedTargets.push({\n          ...target,\n          datasource: targetKey,\n        });\n      }\n    }\n    for (const target of updatedTargets) {\n      if (!target.refId) {\n        target.refId = getNextRefIdChar(updatedTargets);\n      }\n    }\n    panel.targets = updatedTargets;\n    delete panel.datasources;\n  }\n\n  if (schemaVersion < 8) {\n    if (panel.targets.length === 1) {\n      if (panel.targets[0].datasource) {\n        panel.datasource = panel.targets[0].datasource;\n        delete panel.targets[0].datasource;\n      }\n    } else if (panel.targets.length > 1) {\n      // Mixed data sources\n      panel.datasource = '-- Mixed --';\n    }\n    for (const target of panel.targets) {\n      // set queryType to PROBLEMS\n      target.queryType = 5;\n      target.showProblems = migrateShowEvents(panel);\n      target.options = migrateOptions(panel);\n\n      _.defaults(target.options, getDefaultTargetOptions());\n      _.defaults(target, { tags: { filter: \"\" } });\n    }\n\n    panel.sortProblems = panel.sortTriggersBy?.value === 'priority' ? 'priority' : 'lastchange';\n\n    delete panel.showEvents;\n    delete panel.showTriggers;\n    delete panel.hostsInMaintenance;\n    delete panel.sortTriggersBy;\n  }\n\n  return panel;\n}\n\nfunction migrateOptions(panel) {\n  let acknowledged = 2;\n  if (panel.showTriggers === 'acknowledged') {\n    acknowledged = 1;\n  } else if (panel.showTriggers === 'unacknowledged') {\n    acknowledged = 0;\n  }\n\n  // Default limit in Zabbix\n  let limit = 1001;\n  if (panel.limit && panel.limit !== 100) {\n    limit = panel.limit;\n  }\n\n  return {\n    hostsInMaintenance: panel.hostsInMaintenance,\n    sortProblems: panel.sortTriggersBy?.value === 'priority' ? 'priority' : 'default',\n    minSeverity: 0,\n    acknowledged: acknowledged,\n    limit: limit,\n  };\n}\n\nfunction migrateShowEvents(panel) {\n  if (panel.showEvents?.value === 1) {\n    return ShowProblemTypes.Problems;\n  } else if (panel.showEvents?.value === 0 || panel.showEvents?.value?.length > 1) {\n    return ShowProblemTypes.History;\n  } else {\n    return ShowProblemTypes.Problems;\n  }\n}\n\nfunction getSchemaVersion(panel) {\n  return panel.schemaVersion || 1;\n}\n\nfunction isEmptyPanel(panel) {\n  return !panel.datasource && !panel.datasources && !panel.triggers && isEmptyTargets(panel.targets);\n}\n\nfunction isEmptyTargets(targets) {\n  return !targets || (_.isArray(targets) && (targets.length === 0 || targets.length === 1 && _.isEmpty(targets[0])));\n}\n\nfunction isDefaultPanel(panel) {\n  return panel.targets && panel.targets.length === 1 && isDefaultTarget(panel.targets[0]);\n}\n\nfunction isDefaultTarget(target) {\n  return !target.group?.filter && !target.host?.filter && !target.application?.filter && !target.trigger?.filter && !target.queryType;\n}\n\nfunction isEmptyTarget(target) {\n  return !target || !(target.group && target.host && target.application && target.trigger);\n}\n\nfunction isInvalidTarget(target, targetKey) {\n  return target && target.refId === 'A' && targetKey === '0';\n}\n","const { MAX_SAFE_COMPONENT_LENGTH } = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst createToken = (name, value, isGlobal) => {\n  const index = R++\n  debug(index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*')\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\.0\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\.0\\.0-0\\\\s*$')\n","const {MAX_LENGTH} = require('../internal/constants')\nconst { re, t } = require('../internal/re')\nconst SemVer = require('../classes/semver')\n\nconst parse = (version, options) => {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  const r = options.loose ? re[t.LOOSE] : re[t.FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nmodule.exports = parse\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\nmodule.exports = {\n  SEMVER_SPEC_VERSION,\n  MAX_LENGTH,\n  MAX_SAFE_INTEGER,\n  MAX_SAFE_COMPONENT_LENGTH\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n  constructor (comp, options) {\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (!options || typeof options !== 'object') {\n      options = {\n        loose: !!options,\n        includePrerelease: false\n      }\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    const sameDirectionIncreasing =\n      (this.operator === '>=' || this.operator === '>') &&\n      (comp.operator === '>=' || comp.operator === '>')\n    const sameDirectionDecreasing =\n      (this.operator === '<=' || this.operator === '<') &&\n      (comp.operator === '<=' || comp.operator === '<')\n    const sameSemVer = this.semver.version === comp.semver.version\n    const differentDirectionsInclusive =\n      (this.operator === '>=' || this.operator === '<=') &&\n      (comp.operator === '>=' || comp.operator === '<=')\n    const oppositeDirectionsLessThan =\n      cmp(this.semver, '<', comp.semver, options) &&\n      (this.operator === '>=' || this.operator === '>') &&\n        (comp.operator === '<=' || comp.operator === '<')\n    const oppositeDirectionsGreaterThan =\n      cmp(this.semver, '>', comp.semver, options) &&\n      (this.operator === '<=' || this.operator === '<') &&\n        (comp.operator === '>=' || comp.operator === '>')\n\n    return (\n      sameDirectionIncreasing ||\n      sameDirectionDecreasing ||\n      (sameSemVer && differentDirectionsInclusive) ||\n      oppositeDirectionsLessThan ||\n      oppositeDirectionsGreaterThan\n    )\n  }\n}\n\nmodule.exports = Comparator\n\nconst {re, t} = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","module.exports = __WEBPACK_EXTERNAL_MODULE__29__;","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers\n}\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst {ANY} = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","module.exports = __WEBPACK_EXTERNAL_MODULE__37__;","module.exports = __WEBPACK_EXTERNAL_MODULE__38__;","module.exports = __WEBPACK_EXTERNAL_MODULE__39__;","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","module.exports = __WEBPACK_EXTERNAL_MODULE__43__;","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nmodule.exports = {\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: require('./internal/constants').SEMVER_SPEC_VERSION,\n  SemVer: require('./classes/semver'),\n  compareIdentifiers: require('./internal/identifiers').compareIdentifiers,\n  rcompareIdentifiers: require('./internal/identifiers').rcompareIdentifiers,\n  parse: require('./functions/parse'),\n  valid: require('./functions/valid'),\n  clean: require('./functions/clean'),\n  inc: require('./functions/inc'),\n  diff: require('./functions/diff'),\n  major: require('./functions/major'),\n  minor: require('./functions/minor'),\n  patch: require('./functions/patch'),\n  prerelease: require('./functions/prerelease'),\n  compare: require('./functions/compare'),\n  rcompare: require('./functions/rcompare'),\n  compareLoose: require('./functions/compare-loose'),\n  compareBuild: require('./functions/compare-build'),\n  sort: require('./functions/sort'),\n  rsort: require('./functions/rsort'),\n  gt: require('./functions/gt'),\n  lt: require('./functions/lt'),\n  eq: require('./functions/eq'),\n  neq: require('./functions/neq'),\n  gte: require('./functions/gte'),\n  lte: require('./functions/lte'),\n  cmp: require('./functions/cmp'),\n  coerce: require('./functions/coerce'),\n  Comparator: require('./classes/comparator'),\n  Range: require('./classes/range'),\n  satisfies: require('./functions/satisfies'),\n  toComparators: require('./ranges/to-comparators'),\n  maxSatisfying: require('./ranges/max-satisfying'),\n  minSatisfying: require('./ranges/min-satisfying'),\n  minVersion: require('./ranges/min-version'),\n  validRange: require('./ranges/valid'),\n  outside: require('./ranges/outside'),\n  gtr: require('./ranges/gtr'),\n  ltr: require('./ranges/ltr'),\n  intersects: require('./ranges/intersects'),\n  simplifyRange: require('./ranges/simplify'),\n  subset: require('./ranges/subset'),\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__45__;","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier) => {\n  if (typeof (options) === 'string') {\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(version, options).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const parse = require('./parse')\nconst eq = require('./eq')\n\nconst diff = (version1, version2) => {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    const v1 = parse(version1)\n    const v2 = parse(version2)\n    const hasPre = v1.prerelease.length || v2.prerelease.length\n    const prefix = hasPre ? 'pre' : ''\n    const defaultResult = hasPre ? 'prerelease' : ''\n    for (const key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\nmodule.exports = diff\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst {re, t} = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    let next\n    while ((next = re[t.COERCERTL].exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    re[t.COERCERTL].lastIndex = -1\n  }\n\n  if (match === null)\n    return null\n\n  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)\n}\nmodule.exports = coerce\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\nmodule.exports = intersects\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let min = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!min)\n        min = version\n    } else {\n      if (prev) {\n        set.push([min, prev])\n      }\n      prev = null\n      min = null\n    }\n  }\n  if (min)\n    set.push([min, null])\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max)\n      ranges.push(min)\n    else if (!max && min === v[0])\n      ranges.push('*')\n    else if (!max)\n      ranges.push(`>=${min}`)\n    else if (min === v[0])\n      ranges.push(`<=${max}`)\n    else\n      ranges.push(`${min} - ${max}`)\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst { ANY } = require('../classes/comparator.js')\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a subset of some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else return false\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n// - If LT\n//   - If LT.semver is greater than that of any > comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n// - If any C is a = range, and GT or LT are set, return false\n// - Else return true\n\nconst subset = (sub, dom, options) => {\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub)\n        continue OUTER\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull)\n      return false\n  }\n  return true\n}\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub.length === 1 && sub[0].semver === ANY)\n    return dom.length === 1 && dom[0].semver === ANY\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=')\n      gt = higherGT(gt, c, options)\n    else if (c.operator === '<' || c.operator === '<=')\n      lt = lowerLT(lt, c, options)\n    else\n      eqSet.add(c.semver)\n  }\n\n  if (eqSet.size > 1)\n    return null\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0)\n      return null\n    else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<='))\n      return null\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options))\n      return null\n\n    if (lt && !satisfies(eq, String(lt), options))\n      return null\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options))\n        return false\n    }\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c)\n          return false\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options))\n        return false\n    }\n    if (lt) {\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c)\n          return false\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options))\n        return false\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0)\n      return false\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0)\n    return false\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0)\n    return false\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a)\n    return b\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","import _ from 'lodash';\nimport { ZabbixMetricsQuery } from './types';\nimport * as c from './constants';\n\n/**\n * Query format migration.\n * This module can detect query format version and make migration.\n */\n\nexport function isGrafana2target(target) {\n  if (!target.mode || target.mode === 0 || target.mode === 2) {\n    if ((target.hostFilter || target.itemFilter || target.downsampleFunction ||\n        (target.host && target.host.host)) &&\n        (target.item.filter === undefined && target.host.filter === undefined)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n}\n\nexport function migrateFrom2To3version(target: ZabbixMetricsQuery) {\n  target.group.filter = target.group.name === \"*\" ? \"/.*/\" : target.group.name;\n  target.host.filter = target.host.name === \"*\" ? convertToRegex(target.hostFilter) : target.host.name;\n  target.application.filter = target.application.name === \"*\" ? \"\" : target.application.name;\n  target.item.filter = target.item.name === \"All\" ? convertToRegex(target.itemFilter) : target.item.name;\n  return target;\n}\n\nfunction migratePercentileAgg(target) {\n  if (target.functions) {\n    for (const f of target.functions) {\n      if (f.def && f.def.name === 'percentil') {\n        f.def.name = 'percentile';\n      }\n    }\n  }\n}\n\nfunction migrateQueryType(target) {\n  if (target.queryType === undefined) {\n    if (target.mode === 'Metrics') {\n      // Explore mode\n      target.queryType = c.MODE_METRICS;\n    } else if (target.mode !== undefined) {\n      target.queryType = target.mode;\n      delete target.mode;\n    }\n  }\n}\n\nfunction migrateSLA(target) {\n  if (target.queryType === c.MODE_ITSERVICE && !target.slaInterval) {\n    target.slaInterval = 'none';\n  }\n}\n\nfunction migrateProblemSort(target) {\n  if (target.options?.sortProblems === 'priority') {\n    target.options.sortProblems = 'severity';\n  }\n}\n\nexport function migrate(target) {\n  target.resultFormat = target.resultFormat || 'time_series';\n  target = fixTargetGroup(target);\n  if (isGrafana2target(target)) {\n    return migrateFrom2To3version(target);\n  }\n  migratePercentileAgg(target);\n  migrateQueryType(target);\n  migrateSLA(target);\n  migrateProblemSort(target);\n  return target;\n}\n\nfunction fixTargetGroup(target) {\n  if (target.group && Array.isArray(target.group)) {\n    target.group = { 'filter': \"\" };\n  }\n  return target;\n}\n\nfunction convertToRegex(str) {\n  if (str) {\n    return '/' + str + '/';\n  } else {\n    return '/.*/';\n  }\n}\n\nexport const DS_CONFIG_SCHEMA = 2;\nexport function migrateDSConfig(jsonData) {\n  if (!jsonData) {\n    jsonData = {};\n  }\n\n  if (!shouldMigrateDSConfig(jsonData)) {\n    return jsonData;\n  }\n\n  const oldVersion = jsonData.schema || 1;\n  jsonData.schema = DS_CONFIG_SCHEMA;\n\n  if (oldVersion < 2) {\n    const dbConnectionOptions = jsonData.dbConnection || {};\n    jsonData.dbConnectionEnable = dbConnectionOptions.enable || false;\n    jsonData.dbConnectionDatasourceId = dbConnectionOptions.datasourceId || null;\n    delete jsonData.dbConnection;\n  }\n\n  return jsonData;\n}\n\nfunction shouldMigrateDSConfig(jsonData): boolean {\n  if (jsonData.dbConnection && !_.isEmpty(jsonData.dbConnection)) {\n    return true;\n  }\n  if (jsonData.schema && jsonData.schema !== DS_CONFIG_SCHEMA) {\n    return true;\n  }\n  return false;\n}\n","import _ from 'lodash';\nimport { isNumeric } from './utils';\n\nconst index = [];\nconst categories = {\n  Transform: [],\n  Aggregate: [],\n  Filter: [],\n  Trends: [],\n  Time: [],\n  Alias: [],\n  Special: []\n};\n\nfunction addFuncDef(funcDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  if (funcDef.category) {\n    categories[funcDef.category].push(funcDef);\n  }\n  index[funcDef.name] = funcDef;\n  index[funcDef.shortName || funcDef.name] = funcDef;\n}\n\n// Transform\n\naddFuncDef({\n  name: 'groupBy',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string'},\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'float', options: [100, 0.01, 10, -1]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [\n    { name: 'delta', type: 'float', options: [-100, 100]}\n  ],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'delta',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'rate',\n  category: 'Transform',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'factor', type: 'int', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Transform',\n  params: [\n    { name: 'smoothing', type: 'float', options: [6, 10, 60, 100, 600] }\n  ],\n  defaultParams: [0.2],\n});\n\naddFuncDef({\n  name: 'percentile',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'},\n  ],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [\n    {name: 'number', type: 'float'}\n  ],\n  defaultParams: [0],\n});\n\n// Aggregate\n\naddFuncDef({\n  name: 'sumSeries',\n  category: 'Aggregate',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'median',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string'}\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'average',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'percentileAgg',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'percent', type: 'float', options: [25, 50, 75, 90, 95, 99, 99.9] }\n  ],\n  defaultParams: ['1m', 95],\n});\n\naddFuncDef({\n  name: 'min',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'max',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'sum',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'count',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' }\n  ],\n  defaultParams: ['1m'],\n});\n\naddFuncDef({\n  name: 'aggregateBy',\n  category: 'Aggregate',\n  params: [\n    { name: 'interval', type: 'string' },\n    { name: 'function', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: ['1m', 'avg'],\n});\n\n// Filter\n\naddFuncDef({\n  name: 'top',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'bottom',\n  category: 'Filter',\n  params: [\n    { name: 'number', type: 'int' },\n    { name: 'value', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count', 'median'] }\n  ],\n  defaultParams: [5, 'avg'],\n});\n\naddFuncDef({\n  name: 'sortSeries',\n  category: 'Filter',\n  params: [\n    { name: 'direction', type: 'string', options: ['asc', 'desc'] }\n  ],\n  defaultParams: ['asc']\n});\n\n// Trends\n\naddFuncDef({\n  name: 'trendValue',\n  category: 'Trends',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n// Time\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Time',\n  params: [\n    { name: 'interval', type: 'string', options: ['24h', '7d', '1M', '+24h', '-24h']}\n  ],\n  defaultParams: ['24h'],\n});\n\n//Alias\n\naddFuncDef({\n  name: 'setAlias',\n  category: 'Alias',\n  params: [\n    { name: 'alias', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'setAliasByRegex',\n  category: 'Alias',\n  params: [\n    { name: 'aliasByRegex', type: 'string' }\n  ],\n  defaultParams: []\n});\n\naddFuncDef({\n  name: 'replaceAlias',\n  category: 'Alias',\n  params: [\n    { name: 'regexp', type: 'string' },\n    { name: 'newAlias', type: 'string' }\n  ],\n  defaultParams: ['/(.*)/', '$1']\n});\n\n// Special\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    { name: 'type', type: 'string', options: ['avg', 'min', 'max', 'sum', 'count'] }\n  ],\n  defaultParams: ['avg'],\n});\n\n_.each(categories, (funcList, catName) => {\n  categories[catName] = _.sortBy(funcList, 'name');\n});\n\nclass FuncInstance {\n  def: any;\n  params: any;\n  text: string;\n  added: boolean;\n\n  constructor(funcDef, params) {\n    this.def = funcDef;\n\n    if (params) {\n      this.params = params;\n    } else {\n      // Create with default params\n      this.params = [];\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  bindFunction(metricFunctions) {\n    const func = metricFunctions[this.def.name];\n    if (func) {\n\n      // Bind function arguments\n      let bindedFunc = func;\n      let param;\n      for (let i = 0; i < this.params.length; i++) {\n        param = this.params[i];\n\n        // Convert numeric params\n        if (this.def.params[i].type === 'int' ||\n            this.def.params[i].type === 'float') {\n          param = Number(param);\n        }\n        bindedFunc = _.partial(bindedFunc, param);\n      }\n      return bindedFunc;\n    } else {\n      throw { message: 'Method not found ' + this.def.name };\n    }\n  }\n\n  render(metricExp) {\n    const str = this.def.name + '(';\n    const parameters = _.map(this.params, (value, index) => {\n      const paramType = this.def.params[index].type;\n      if (paramType === 'int' ||\n          paramType === 'float' ||\n          paramType === 'value_or_series' ||\n          paramType === 'boolean') {\n        return value;\n      } else if (paramType === 'int_or_interval' && isNumeric(value)) {\n        return value;\n      }\n\n      return \"'\" + value + \"'\";\n\n    });\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue, index) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    return this.def.params[index + 1] && this.def.params[index + 1].optional;\n  }\n\n  updateParam(strValue, index) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), (partVal, idx) => {\n        this.updateParam(partVal.trim(), idx);\n      });\n      return;\n    }\n\n    if (strValue === '' && this.def.params[index].optional) {\n      this.params.splice(index, 1);\n    }else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    let text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nexport function createFuncInstance(funcDef, params?) {\n  if (_.isString(funcDef)) {\n    if (!index[funcDef]) {\n      throw { message: 'Method not found ' + name };\n    }\n    funcDef = index[funcDef];\n  }\n  return new FuncInstance(funcDef, params);\n}\n\nexport function getFuncDef(name) {\n  return index[name];\n}\n\nexport function getCategories() {\n  return categories;\n}\n","/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\nimport * as c from './constants';\nimport { TimeSeriesPoints, TimeSeriesValue } from '@grafana/data';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\nconst HOUR_MS = 3600 * 1000;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  const downsampledSeries = [];\n  const timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  let points_sum = 0;\n  let points_num = 0;\n  let value_avg = 0;\n  let frame = [];\n\n  for (let i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    } else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      } else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      } else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Detects interval between data points and aligns time series. If there's no value in the interval, puts null as a value.\n */\nexport function align(datapoints: TimeSeriesPoints, interval?: number): TimeSeriesPoints {\n  if (!interval) {\n    interval = detectSeriesInterval(datapoints);\n  }\n\n  if (interval <= 0 || datapoints.length <= 1) {\n    return datapoints;\n  }\n\n  const aligned_ts: TimeSeriesPoints = [];\n  let frame_ts = getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], interval);\n  let point_frame_ts = frame_ts;\n  let point: TimeSeriesValue[];\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], interval);\n\n    if (point_frame_ts > frame_ts) {\n      // Move frame window to next non-empty interval and fill empty by null\n      while (frame_ts < point_frame_ts) {\n        aligned_ts.push([null, frame_ts]);\n        frame_ts += interval;\n      }\n    }\n\n    aligned_ts.push([point[POINT_VALUE], point_frame_ts]);\n    frame_ts += interval;\n  }\n  return aligned_ts;\n}\n\n/**\n * Detects interval between data points in milliseconds.\n */\nfunction detectSeriesInterval(datapoints: TimeSeriesPoints): number {\n  if (datapoints.length < 2) {\n    return -1;\n  }\n\n  let deltas = [];\n  for (let i = 1; i < datapoints.length; i++) {\n    // Get deltas (in seconds)\n    const d = (datapoints[i][POINT_TIMESTAMP] - datapoints[i - 1][POINT_TIMESTAMP]) / 1000;\n    deltas.push(Math.round(d));\n  }\n\n  // Use 50th percentile (median) as an interval\n  deltas = _.sortBy(deltas);\n  const intervalSec = deltas[Math.floor(deltas.length * 0.5)];\n  return intervalSec * 1000;\n}\n\nexport function fillTrendsWithNulls(datapoints: TimeSeriesPoints): TimeSeriesPoints {\n  if (datapoints.length <= 1) {\n    return datapoints;\n  }\n\n  const interval = HOUR_MS;\n  const filled_ts: TimeSeriesPoints = [];\n  let frame_ts = datapoints[0][POINT_TIMESTAMP];\n  let point_frame_ts = frame_ts;\n  let point: TimeSeriesValue[];\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = point[POINT_TIMESTAMP];\n\n    if (point_frame_ts > frame_ts) {\n      // Move frame window to next non-empty interval and fill empty by null\n      while (frame_ts < point_frame_ts) {\n        filled_ts.push([null, frame_ts]);\n        frame_ts += interval;\n      }\n    }\n\n    filled_ts.push(point);\n    frame_ts += interval;\n  }\n  return filled_ts;\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  const ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  const frames = _.groupBy(datapoints, point => {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  const grouped = _.mapValues(frames, frame => {\n    const points = _.map(frame, point => {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, (value, timestamp) => {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nexport function groupBy_perf(datapoints, interval, groupByCallback) {\n  if (datapoints.length === 0) {\n    return [];\n  }\n\n  if (interval === c.RANGE_VARIABLE_VALUE) {\n    return groupByRange(datapoints, groupByCallback);\n  }\n\n  const ms_interval = utils.parseInterval(interval);\n  const grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\nexport function groupByRange(datapoints, groupByCallback) {\n  const frame_values = [];\n  const frame_start = datapoints[0][POINT_TIMESTAMP];\n  const frame_end = datapoints[datapoints.length - 1][POINT_TIMESTAMP];\n  let point;\n  for (let i = 0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    frame_values.push(point[POINT_VALUE]);\n  }\n  const frame_value = groupByCallback(frame_values);\n  return [[frame_value, frame_start], [frame_value, frame_end]];\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  let new_timestamps = _.uniq(_.map(_.flatten(timeseries), point => {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  const interpolated_timeseries = _.map(timeseries, series => {\n    series = fillZeroes(series, new_timestamps);\n    const timestamps = _.map(series, point => {\n      return point[1];\n    });\n    const new_points = _.map(_.difference(new_timestamps, timestamps), timestamp => {\n      return [null, timestamp];\n    });\n    const new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  const new_timeseries = [];\n  let sum;\n  for (let i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (let j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\nfunction offset(datapoints, delta) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] + delta,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  const newSeries = [];\n  let deltaValue;\n  for (let i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  const newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction simpleMovingAverage(datapoints: TimeSeriesPoints, n: number): TimeSeriesPoints {\n  // It's not possible to calculate MA if n greater than number of points\n  n = Math.min(n, datapoints.length);\n\n  const sma = [];\n  let w_sum;\n  let w_avg = null;\n  let w_count = 0;\n\n  // Initial window\n  for (let j = n; j > 0; j--) {\n    if (datapoints[n - j][POINT_VALUE] !== null) {\n      w_avg += datapoints[n - j][POINT_VALUE];\n      w_count++;\n    }\n  }\n  if (w_count > 0) {\n    w_avg = w_avg / w_count;\n  } else {\n    w_avg = null;\n  }\n  sma.push([w_avg, datapoints[n - 1][POINT_TIMESTAMP]]);\n\n  for (let i = n; i < datapoints.length; i++) {\n    // Insert next value\n    if (datapoints[i][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      w_avg = (w_sum + datapoints[i][POINT_VALUE]) / (w_count + 1);\n      w_count++;\n    }\n    // Remove left side point\n    if (datapoints[i - n][POINT_VALUE] !== null) {\n      w_sum = w_avg * w_count;\n      if (w_count > 1) {\n        w_avg = (w_sum - datapoints[i - n][POINT_VALUE]) / (w_count - 1);\n        w_count--;\n      } else {\n        w_avg = null;\n        w_count = 0;\n      }\n    }\n    sma.push([w_avg, datapoints[i][POINT_TIMESTAMP]]);\n  }\n  return sma;\n}\n\nfunction expMovingAverage(datapoints: TimeSeriesPoints, n: number): TimeSeriesPoints {\n  // It's not possible to calculate MA if n greater than number of points\n  n = Math.min(n, datapoints.length);\n\n  let ema = [datapoints[0]];\n  let ema_prev = datapoints[0][POINT_VALUE];\n  let ema_cur;\n  let a;\n\n  if (n > 1) {\n    // Calculate a from window size\n    a = 2 / (n + 1);\n\n    // Initial window, use simple moving average\n    let w_avg = null;\n    let w_count = 0;\n    for (let j = n; j > 0; j--) {\n      if (datapoints[n - j][POINT_VALUE] !== null) {\n        w_avg += datapoints[n - j][POINT_VALUE];\n        w_count++;\n      }\n    }\n    if (w_count > 0) {\n      w_avg = w_avg / w_count;\n      // Actually, we should set timestamp from datapoints[n-1] and start calculation of EMA from n.\n      // But in order to start EMA from first point (not from Nth) we should expand time range and request N additional\n      // points outside left side of range. We can't do that, so this trick is used for pretty view of first N points.\n      // We calculate AVG for first N points, but then start from 2nd point, not from Nth. In general, it means we\n      // assume that previous N values (0-N, 0-(N-1), ..., 0-1) have the same average value as a first N values.\n      ema = [[w_avg, datapoints[0][POINT_TIMESTAMP]]];\n      ema_prev = w_avg;\n      n = 1;\n    }\n  } else {\n    // Use predefined a and start from 1st point (use it as initial EMA value)\n    a = n;\n    n = 1;\n  }\n\n  for (let i = n; i < datapoints.length; i++) {\n    if (datapoints[i][POINT_VALUE] !== null) {\n      ema_cur = a * datapoints[i][POINT_VALUE] + (1 - a) * ema_prev;\n      ema_prev = ema_cur;\n      ema.push([ema_cur, datapoints[i][POINT_TIMESTAMP]]);\n    } else {\n      ema.push([null, datapoints[i][POINT_TIMESTAMP]]);\n    }\n  }\n  return ema;\n}\n\nfunction PERCENTILE(n, values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length * n / 100)];\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  let sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  const values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  const values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  const sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, point => {\n    return point[1];\n  });\n}\n\n/**\n * Fill empty front and end of series by zeroes.\n *\n * |   ***   |    |   ***   |\n * |___   ___| -> |***   ***|\n * @param {*} series\n * @param {*} timestamps\n */\nfunction fillZeroes(series, timestamps) {\n  const prepend = [];\n  const append = [];\n  let new_point;\n  for (let i = 0; i < timestamps.length; i++) {\n    if (timestamps[i] < series[0][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      prepend.push(new_point);\n    } else if (timestamps[i] > series[series.length - 1][POINT_TIMESTAMP]) {\n      new_point = [0, timestamps[i]];\n      append.push(new_point);\n    }\n  }\n  return _.concat(_.concat(prepend, series), append);\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  let left, right;\n\n  // Interpolate series\n  for (let i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, i);\n      right = findNearestRight(series, i);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, pointIndex) {\n  for (let i = pointIndex; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction findNearestLeft(series, pointIndex) {\n  for (let i = pointIndex; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return null;\n}\n\nfunction flattenDatapoints(datapoints) {\n  const depth = utils.getArrayDepth(datapoints);\n  if (depth <= 2) {\n    // Don't process if datapoints already flattened\n    return datapoints;\n  }\n  return _.flatten(datapoints);\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  groupByRange,\n  sumSeries,\n  scale,\n  offset,\n  scale_perf,\n  delta,\n  rate,\n  simpleMovingAverage,\n  expMovingAverage,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN,\n  PERCENTILE,\n  sortByTime,\n  flattenDatapoints,\n  align,\n};\n\nexport default exportedFunctions;\n","import _ from 'lodash';\n// Available in 7.0\n// import { getTemplateSrv } from '@grafana/runtime';\nimport * as utils from './utils';\nimport ts, { groupBy_perf as groupBy } from './timeseries';\n\nconst SUM = ts.SUM;\nconst COUNT = ts.COUNT;\nconst AVERAGE = ts.AVERAGE;\nconst MIN = ts.MIN;\nconst MAX = ts.MAX;\nconst MEDIAN = ts.MEDIAN;\nconst PERCENTILE = ts.PERCENTILE;\n\nconst downsampleSeries = ts.downsample;\nconst groupBy_exported = (interval, groupFunc, datapoints) => groupBy(datapoints, interval, groupFunc);\nconst sumSeries = ts.sumSeries;\nconst delta = ts.delta;\nconst rate = ts.rate;\nconst scale = (factor, datapoints) => ts.scale_perf(datapoints, factor);\nconst offset = (delta, datapoints) => ts.offset(datapoints, delta);\nconst simpleMovingAverage = (n, datapoints) => ts.simpleMovingAverage(datapoints, n);\nconst expMovingAverage = (a, datapoints) => ts.expMovingAverage(datapoints, a);\nconst percentile = (interval, n, datapoints) => groupBy(datapoints, interval, _.partial(PERCENTILE, n));\n\nfunction limit(order, n, orderByFunc, timeseries) {\n  const orderByCallback = aggregationFunctions[orderByFunc];\n  const sortByIteratee = (ts) => {\n    const values = _.map(ts.datapoints, (point) => {\n      return point[0];\n    });\n    return orderByCallback(values);\n  };\n  const sortedTimeseries = _.sortBy(timeseries, sortByIteratee);\n  if (order === 'bottom') {\n    return sortedTimeseries.slice(0, n);\n  } else {\n    return sortedTimeseries.slice(-n);\n  }\n}\n\nfunction removeAboveValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] > n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction removeBelowValue(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] < n) ? null : point[0],\n      point[1]\n    ];\n  });\n}\n\nfunction transformNull(n, datapoints) {\n  return _.map(datapoints, point => {\n    return [\n      (point[0] !== null) ? point[0] : n,\n      point[1]\n    ];\n  });\n}\n\nfunction sortSeries(direction, timeseries: any[]) {\n  return _.orderBy(timeseries, [ts => {\n    return ts.target.toLowerCase();\n  }], direction);\n}\n\nfunction setAlias(alias, timeseries) {\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction replaceAlias(regexp, newAlias, timeseries) {\n  let pattern;\n  if (utils.isRegex(regexp)) {\n    pattern = utils.buildRegex(regexp);\n  } else {\n    pattern = regexp;\n  }\n\n  let alias = timeseries.target.replace(pattern, newAlias);\n  // TODO: use getTemplateSrv() when available (since 7.0)\n  if (this.templateSrv && timeseries && timeseries.scopedVars) {\n    alias = this.templateSrv.replace(alias, timeseries.scopedVars);\n  }\n  timeseries.target = alias;\n  return timeseries;\n}\n\nfunction setAliasByRegex(alias, timeseries) {\n  timeseries.target = extractText(timeseries.target, alias);\n  return timeseries;\n}\n\nfunction extractText(str, pattern) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  return extractedValue[0];\n}\n\nfunction groupByWrapper(interval, groupFunc, datapoints) {\n  const groupByCallback = aggregationFunctions[groupFunc];\n  return groupBy(datapoints, interval, groupByCallback);\n}\n\nfunction aggregateByWrapper(interval, aggregateFunc, datapoints) {\n  // Flatten all points in frame and then just use groupBy()\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = aggregationFunctions[aggregateFunc];\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction aggregateWrapper(groupByCallback, interval, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction percentileAgg(interval, n, datapoints) {\n  const flattenedPoints = ts.flattenDatapoints(datapoints);\n  // groupBy_perf works with sorted series only\n  const sortedPoints = ts.sortByTime(flattenedPoints);\n  const groupByCallback = _.partial(PERCENTILE, n);\n  return groupBy(sortedPoints, interval, groupByCallback);\n}\n\nfunction timeShift(interval, range) {\n  const shift = utils.parseTimeShiftInterval(interval) / 1000;\n  return _.map(range, time => {\n    return time - shift;\n  });\n}\n\nfunction unShiftTimeSeries(interval, datapoints) {\n  const unshift = utils.parseTimeShiftInterval(interval);\n  return _.map(datapoints, dp => {\n    return [\n      dp[0],\n      dp[1] + unshift\n    ];\n  });\n}\n\nconst metricFunctions = {\n  groupBy: groupByWrapper,\n  scale: scale,\n  offset: offset,\n  delta: delta,\n  rate: rate,\n  movingAverage: simpleMovingAverage,\n  exponentialMovingAverage: expMovingAverage,\n  percentile: percentile,\n  transformNull: transformNull,\n  aggregateBy: aggregateByWrapper,\n  // Predefined aggs\n  percentileAgg: percentileAgg,\n  average: _.partial(aggregateWrapper, AVERAGE),\n  min: _.partial(aggregateWrapper, MIN),\n  max: _.partial(aggregateWrapper, MAX),\n  median: _.partial(aggregateWrapper, MEDIAN),\n  sum: _.partial(aggregateWrapper, SUM),\n  count: _.partial(aggregateWrapper, COUNT),\n  sumSeries: sumSeries,\n  removeAboveValue: removeAboveValue,\n  removeBelowValue: removeBelowValue,\n  top: _.partial(limit, 'top'),\n  bottom: _.partial(limit, 'bottom'),\n  sortSeries: sortSeries,\n  timeShift: timeShift,\n  setAlias: setAlias,\n  setAliasByRegex: setAliasByRegex,\n  replaceAlias: replaceAlias\n};\n\nconst aggregationFunctions = {\n  avg: AVERAGE,\n  min: MIN,\n  max: MAX,\n  median: MEDIAN,\n  sum: SUM,\n  count: COUNT\n};\n\nexport default {\n  downsampleSeries: downsampleSeries,\n  groupBy: groupBy_exported,\n  AVERAGE: AVERAGE,\n  MIN: MIN,\n  MAX: MAX,\n  MEDIAN: MEDIAN,\n  SUM: SUM,\n  COUNT: COUNT,\n  unShiftTimeSeries: unShiftTimeSeries,\n\n  get aggregationFunctions() {\n    return aggregationFunctions;\n  },\n\n  get metricFunctions() {\n    return metricFunctions;\n  }\n};\n","import _ from 'lodash';\nimport TableModel from 'grafana/app/core/table_model';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport { ArrayVector, DataFrame, Field, FieldType, MutableDataFrame, MutableField, TIME_SERIES_TIME_FIELD_NAME, TIME_SERIES_VALUE_FIELD_NAME } from '@grafana/data';\nimport { ZabbixMetricsQuery } from './types';\n\n/**\n * Convert Zabbix API history.get response to Grafana format\n *\n * @return {Array}            Array of timeseries in Grafana format\n *                            {\n *                               target: \"Metric name\",\n *                               datapoints: [[<value>, <unixtime>], ...]\n *                            }\n */\nfunction convertHistory(history, items, addHostName, convertPointCallback) {\n  /**\n   * Response should be in the format:\n   * data: [\n   *          {\n   *             target: \"Metric name\",\n   *             datapoints: [[<value>, <unixtime>], ...]\n   *          }, ...\n   *       ]\n   */\n\n  // Group history by itemid\n  const grouped_history = _.groupBy(history, 'itemid');\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');  //uniqBy is needed to deduplicate\n\n  return _.map(grouped_history, (hist, itemid) => {\n    const item = _.find(items, {'itemid': itemid}) as any;\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars: any = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n      '__zbx_item_interval': { value: item.delay },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n\n    return {\n      target: alias,\n      datapoints: _.map(hist, convertPointCallback),\n      scopedVars,\n      item\n    };\n  });\n}\n\nexport function seriesToDataFrame(timeseries, target: ZabbixMetricsQuery, valueMappings?: any[], fieldType?: FieldType): MutableDataFrame {\n  const { datapoints, scopedVars, target: seriesName, item } = timeseries;\n\n  const timeFiled: Field = {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {\n      custom: {}\n    },\n    values: new ArrayVector<number>(datapoints.map(p => p[c.DATAPOINT_TS])),\n  };\n\n  let values: ArrayVector<number> | ArrayVector<string>;\n  if (fieldType === FieldType.string) {\n    values = new ArrayVector<string>(datapoints.map(p => p[c.DATAPOINT_VALUE]));\n  } else {\n    values = new ArrayVector<number>(datapoints.map(p => p[c.DATAPOINT_VALUE]));\n  }\n\n  const valueFiled: Field = {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: fieldType ?? FieldType.number,\n    labels: {},\n    config: {\n      displayNameFromDS: seriesName,\n      custom: {}\n    },\n    values,\n  };\n\n  if (scopedVars) {\n    timeFiled.config.custom = {\n      itemInterval: scopedVars['__zbx_item_interval']?.value,\n    };\n\n    valueFiled.labels = {\n      host: scopedVars['__zbx_host_name']?.value,\n      item: scopedVars['__zbx_item']?.value,\n      item_key: scopedVars['__zbx_item_key']?.value,\n    };\n\n    valueFiled.config.custom = {\n      itemInterval: scopedVars['__zbx_item_interval']?.value,\n    };\n  }\n\n  if (item) {\n    // Try to use unit configured in Zabbix\n    const unit = utils.convertZabbixUnit(item.units);\n    if (unit) {\n      console.log(`Datasource: unit detected: ${unit} (${item.units})`);\n      valueFiled.config.unit = unit;\n\n      if (unit === 'percent') {\n        valueFiled.config.min = 0;\n        valueFiled.config.max = 100;\n      }\n    }\n\n    // Try to use value mapping from Zabbix\n    const mappings = utils.getValueMapping(item, valueMappings);\n    if (mappings && target.options?.useZabbixValueMapping) {\n      console.log(`Datasource: using Zabbix value mapping`);\n      valueFiled.config.mappings = mappings;\n    }\n  }\n\n  const fields: Field[] = [ timeFiled, valueFiled ];\n\n  const frame: DataFrame = {\n    name: seriesName,\n    refId: target.refId,\n    fields,\n    length: datapoints.length,\n  };\n\n  const mutableFrame = new MutableDataFrame(frame);\n  return mutableFrame;\n}\n\nexport function isConvertibleToWide(data: DataFrame[]): boolean {\n  if (!data || data.length < 2) {\n    return false;\n  }\n\n  const first = data[0].fields.find(f => f.type === FieldType.time);\n  if (!first) {\n    return false;\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const timeField = data[i].fields.find(f => f.type === FieldType.time);\n\n    for (let j = 0; j < Math.min(data.length, 2); j++) {\n      if (timeField.values.get(j) !== first.values.get(j)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nexport function alignFrames(data: MutableDataFrame[]): MutableDataFrame[] {\n  if (!data || data.length === 0) {\n    return data;\n  }\n\n  // Get oldest time stamp for all frames\n  let minTimestamp = data[0].fields.find(f => f.name === TIME_SERIES_TIME_FIELD_NAME).values.get(0);\n  for (let i = 0; i < data.length; i++) {\n    const timeField = data[i].fields.find(f => f.name === TIME_SERIES_TIME_FIELD_NAME);\n    const firstTs = timeField.values.get(0);\n    if (firstTs < minTimestamp) {\n      minTimestamp = firstTs;\n    }\n  }\n\n  for (let i = 0; i < data.length; i++) {\n    const frame = data[i];\n    const timeField = frame.fields.find(f => f.name === TIME_SERIES_TIME_FIELD_NAME);\n    const valueField = frame.fields.find(f => f.name === TIME_SERIES_VALUE_FIELD_NAME);\n    const firstTs = timeField.values.get(0);\n\n    if (firstTs > minTimestamp) {\n      console.log('Data frames: adding missing points');\n      let timestamps = timeField.values.toArray();\n      let values = valueField.values.toArray();\n      const missingTimestamps = [];\n      const missingValues = [];\n      const frameInterval: number = timeField.config.custom?.itemInterval;\n      for (let j = minTimestamp; j < firstTs; j+=frameInterval) {\n        missingTimestamps.push(j);\n        missingValues.push(null);\n      }\n\n      timestamps = missingTimestamps.concat(timestamps);\n      values = missingValues.concat(values);\n      timeField.values = new ArrayVector(timestamps);\n      valueField.values = new ArrayVector(values);\n    }\n  }\n\n  return data;\n}\n\nexport function convertToWide(data: MutableDataFrame[]): DataFrame[] {\n  const timeField = data[0].fields.find(f => f.type === FieldType.time);\n  if (!timeField) {\n    return [];\n  }\n\n  const fields: MutableField[] = [ timeField ];\n\n  for (let i = 0; i < data.length; i++) {\n    const valueField = data[i].fields.find(f => f.name === TIME_SERIES_VALUE_FIELD_NAME);\n    if (!valueField) {\n      continue;\n    }\n\n    valueField.name = data[i].name;\n\n    // Add null value to the end if series is shifted by 1 time frame\n    if (timeField.values.length - valueField.values.length === 1) {\n      valueField.values.add(null);\n    }\n    fields.push(valueField);\n  }\n\n  const frame: DataFrame = {\n    name: \"wide\",\n    fields,\n    length: timeField.values.length,\n  };\n\n  return [frame];\n}\n\nfunction sortTimeseries(timeseries) {\n  // Sort trend data, issue #202\n  _.forEach(timeseries, series => {\n    series.datapoints = _.sortBy(series.datapoints, point => point[c.DATAPOINT_TS]);\n  });\n  return timeseries;\n}\n\nfunction handleHistory(history, items, addHostName = true) {\n  return convertHistory(history, items, addHostName, convertHistoryPoint);\n}\n\nfunction handleTrends(history, items, valueType, addHostName = true) {\n  const convertPointCallback = _.partial(convertTrendPoint, valueType);\n  return convertHistory(history, items, addHostName, convertPointCallback);\n}\n\nfunction handleText(history, items, target, addHostName = true) {\n  const convertTextCallback = _.partial(convertText, target);\n  return convertHistory(history, items, addHostName, convertTextCallback);\n}\n\nfunction handleHistoryAsTable(history, items, target) {\n  const table: any = new TableModel();\n  table.addColumn({text: 'Host'});\n  table.addColumn({text: 'Item'});\n  table.addColumn({text: 'Key'});\n  table.addColumn({text: 'Last value'});\n\n  const grouped_history = _.groupBy(history, 'itemid');\n  _.each(items, (item) => {\n    const itemHistory = grouped_history[item.itemid] || [];\n    const lastPoint = _.last(itemHistory);\n    let lastValue = lastPoint ? lastPoint.value : null;\n\n    if (target.options.skipEmptyValues && (!lastValue || lastValue === '')) {\n      return;\n    }\n\n    // Regex-based extractor\n    if (target.textFilter) {\n      lastValue = extractText(lastValue, target.textFilter, target.useCaptureGroups);\n    }\n\n    let host: any = _.first(item.hosts);\n    host = host ? host.name : \"\";\n\n    table.rows.push([\n      host, item.name, item.key_, lastValue\n    ]);\n  });\n\n  return table;\n}\n\nfunction convertText(target, point) {\n  let value = point.value;\n\n  // Regex-based extractor\n  if (target.textFilter) {\n    value = extractText(point.value, target.textFilter, target.useCaptureGroups);\n  }\n\n  return [\n    value,\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction extractText(str, pattern, useCaptureGroups) {\n  const extractPattern = new RegExp(pattern);\n  const extractedValue = extractPattern.exec(str);\n  if (extractedValue) {\n    if (useCaptureGroups) {\n      return extractedValue[1];\n    } else {\n      return extractedValue[0];\n    }\n  }\n  return \"\";\n}\n\nfunction handleSLAResponse(itservice, slaProperty, slaObject) {\n  const targetSLA = slaObject[itservice.serviceid].sla;\n  if (slaProperty.property === 'status') {\n    const targetStatus = parseInt(slaObject[itservice.serviceid].status, 10);\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: [\n        [targetStatus, targetSLA[0].to * 1000]\n      ]\n    };\n  } else {\n    let i;\n    const slaArr = [];\n    for (i = 0; i < targetSLA.length; i++) {\n      if (i === 0) {\n        slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].from * 1000]);\n      }\n      slaArr.push([targetSLA[i][slaProperty.property], targetSLA[i].to * 1000]);\n    }\n    return {\n      target: itservice.name + ' ' + slaProperty.name,\n      datapoints: slaArr\n    };\n  }\n}\n\nfunction handleTriggersResponse(triggers, groups, timeRange) {\n  if (!_.isArray(triggers)) {\n    let triggersCount = null;\n    try {\n      triggersCount = Number(triggers);\n    } catch (err) {\n      console.log(\"Error when handling triggers count: \", err);\n    }\n    return {\n      target: \"triggers count\",\n      datapoints: [\n        [triggersCount, timeRange[1] * 1000]\n      ]\n    };\n  } else {\n    const stats = getTriggerStats(triggers);\n    const groupNames = _.map(groups, 'name');\n    const table: any = new TableModel();\n    table.addColumn({text: 'Host group'});\n    _.each(_.orderBy(c.TRIGGER_SEVERITY, ['val'], ['desc']), (severity) => {\n      table.addColumn({text: severity.text});\n    });\n    _.each(stats, (severity_stats, group) => {\n      if (_.includes(groupNames, group)) {\n        let row = _.map(_.orderBy(_.toPairs(severity_stats), (s) => s[0], ['desc']), (s) => s[1]);\n        row = _.concat([group], ...row);\n        table.rows.push(row);\n      }\n    });\n    return table;\n  }\n}\n\nfunction getTriggerStats(triggers) {\n  const groups = _.uniq(_.flattenDeep(_.map(triggers, (trigger) => _.map(trigger.groups, 'name'))));\n  // let severity = _.map(c.TRIGGER_SEVERITY, 'text');\n  const stats = {};\n  _.each(groups, (group) => {\n    stats[group] = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0}; // severity:count\n  });\n  _.each(triggers, (trigger) => {\n    _.each(trigger.groups, (group) => {\n      stats[group.name][trigger.priority]++;\n    });\n  });\n  return stats;\n}\n\nfunction convertHistoryPoint(point) {\n  // Value must be a number for properly work\n  return [\n    Number(point.value),\n    point.clock * 1000 + Math.round(point.ns / 1000000)\n  ];\n}\n\nfunction convertTrendPoint(valueType, point) {\n  let value;\n  switch (valueType) {\n    case \"min\":\n      value = point.value_min;\n      break;\n    case \"max\":\n      value = point.value_max;\n      break;\n    case \"avg\":\n      value = point.value_avg;\n      break;\n    case \"sum\":\n      value = point.value_avg * point.num;\n      break;\n    case \"count\":\n      value = point.num;\n      break;\n    default:\n      value = point.value_avg;\n  }\n\n  return [\n    Number(value),\n    point.clock * 1000\n  ];\n}\n\nexport default {\n  handleHistory,\n  convertHistory,\n  handleTrends,\n  handleText,\n  handleHistoryAsTable,\n  handleSLAResponse,\n  handleTriggersResponse,\n  sortTimeseries,\n  seriesToDataFrame,\n  isConvertibleToWide,\n  convertToWide,\n  alignFrames,\n};\n","import _ from 'lodash';\nimport * as utils from '../datasource-zabbix/utils';\nimport { DataFrame, Field, FieldType, ArrayVector } from '@grafana/data';\nimport { ZBXProblem, ZBXTrigger, ProblemDTO, ZBXEvent } from './types';\n\nexport function joinTriggersWithProblems(problems: ZBXProblem[], triggers: ZBXTrigger[]): ProblemDTO[] {\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < problems.length; i++) {\n    const p = problems[i];\n    const triggerId = Number(p.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        timestamp: Number(p.clock),\n        triggerid: p.objectid,\n        eventid: p.eventid,\n        name: p.name,\n        severity: p.severity,\n        acknowledged: p.acknowledged,\n        acknowledges: p.acknowledges,\n        tags: p.tags,\n        suppressed: p.suppressed,\n        suppression_data: p.suppression_data,\n        description: t.description,\n        comments: t.comments,\n        value: t.value,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\ninterface JoinOptions {\n  valueFromEvent?: boolean;\n}\n\nexport function joinTriggersWithEvents(events: ZBXEvent[], triggers: ZBXTrigger[], options?: JoinOptions): ProblemDTO[] {\n  const { valueFromEvent } = options;\n  const problemDTOList: ProblemDTO[] = [];\n\n  for (let i = 0; i < events.length; i++) {\n    const e = events[i];\n    const triggerId = Number(e.objectid);\n    const t = triggers[triggerId];\n\n    if (t) {\n      const problemDTO: ProblemDTO = {\n        value: valueFromEvent ? e.value : t.value,\n        timestamp: Number(e.clock),\n        triggerid: e.objectid,\n        eventid: e.eventid,\n        name: e.name,\n        severity: e.severity,\n        acknowledged: e.acknowledged,\n        acknowledges: e.acknowledges,\n        tags: e.tags,\n        suppressed: e.suppressed,\n        description: t.description,\n        comments: t.comments,\n        groups: t.groups,\n        hosts: t.hosts,\n        items: t.items,\n        alerts: t.alerts,\n        url: t.url,\n        expression: t.expression,\n        correlation_mode: t.correlation_mode,\n        correlation_tag: t.correlation_tag,\n        manual_close: t.manual_close,\n        state: t.state,\n        error: t.error,\n      };\n\n      problemDTOList.push(problemDTO);\n    }\n\n  }\n\n  return problemDTOList;\n}\n\nexport function setMaintenanceStatus(triggers) {\n  _.each(triggers, (trigger) => {\n    const maintenance_status = _.some(trigger.hosts, (host) => host.maintenance_status === '1');\n    trigger.maintenance = maintenance_status;\n  });\n  return triggers;\n}\n\nexport function setAckButtonStatus(triggers, showAckButton) {\n  _.each(triggers, (trigger) => {\n    trigger.showAckButton = showAckButton;\n  });\n  return triggers;\n}\n\nexport function addTriggerDataSource(triggers, target) {\n  _.each(triggers, (trigger) => {\n    trigger.datasource = target.datasource;\n  });\n  return triggers;\n}\n\nexport function addTriggerHostProxy(triggers, proxies) {\n  triggers.forEach(trigger => {\n    if (trigger.hosts && trigger.hosts.length) {\n      const host = trigger.hosts[0];\n      if (host.proxy_hostid !== '0') {\n        const hostProxy = proxies[host.proxy_hostid];\n        host.proxy = hostProxy ? hostProxy.host : '';\n      }\n    }\n  });\n  return triggers;\n}\n\nexport function filterTriggersPre(triggerList, replacedTarget) {\n  // Filter triggers by description\n  const triggerFilter = replacedTarget.trigger.filter;\n  if (triggerFilter) {\n    triggerList = filterTriggers(triggerList, triggerFilter);\n  }\n\n  // Filter by maintenance status\n  if (!replacedTarget.options.hostsInMaintenance) {\n    triggerList = _.filter(triggerList, (trigger) => !trigger.maintenance);\n  }\n\n  return triggerList;\n}\n\nfunction filterTriggers(triggers, triggerFilter) {\n  if (utils.isRegex(triggerFilter)) {\n    return _.filter(triggers, trigger => {\n      return utils.buildRegex(triggerFilter).test(trigger.description);\n    });\n  } else {\n    return _.filter(triggers, trigger => {\n      return trigger.description === triggerFilter;\n    });\n  }\n}\n\nexport function sortProblems(problems: ProblemDTO[], target) {\n  if (target.options?.sortProblems === 'severity') {\n    problems = _.orderBy(problems, ['severity', 'eventid'], ['desc', 'desc']);\n  } else if (target.options?.sortProblems === 'lastchange') {\n    problems = _.orderBy(problems, ['timestamp', 'eventid'], ['desc', 'desc']);\n  }\n  return problems;\n}\n\nexport function toDataFrame(problems: any[]): DataFrame {\n  const problemsField: Field<any> = {\n    name: 'Problems',\n    type: FieldType.other,\n    values: new ArrayVector(problems),\n    config: {\n      custom: {\n        type: 'problems',\n      },\n    },\n  };\n\n  const response: DataFrame = {\n    name: 'problems',\n    fields: [problemsField],\n    length: problems.length,\n  };\n\n  return response;\n}\n\nconst problemsHandler = {\n  addTriggerDataSource,\n  addTriggerHostProxy,\n  setMaintenanceStatus,\n  setAckButtonStatus,\n  filterTriggersPre,\n  sortProblems,\n  toDataFrame,\n  joinTriggersWithProblems,\n  joinTriggersWithEvents,\n};\n\nexport default problemsHandler;\n","/**\n * This module allows to deduplicate function calls with the same params and\n * cache result of function call.\n */\n\nexport class CachingProxy {\n  cacheEnabled: boolean;\n  ttl: number;\n  cache: any;\n  promises: any;\n\n  constructor(cacheOptions) {\n    this.cacheEnabled = cacheOptions.enabled;\n    this.ttl          = cacheOptions.ttl || 600000; // 10 minutes by default\n\n    // Internal objects for data storing\n    this.cache = {};\n    this.promises = {};\n  }\n\n  /**\n   * Check that result is present in the cache and is up to date or send request otherwise.\n   */\n  cacheRequest(func, funcName, funcScope) {\n    return cacheRequest(func, funcName, funcScope, this);\n  }\n\n  /**\n   * Wrap request to prevent multiple calls with same params when request is waiting for response.\n   */\n  proxify(func, funcName, funcScope) {\n    if (!this.promises[funcName]) {\n      this.promises[funcName] = {};\n    }\n    const promiseKeeper = this.promises[funcName];\n    return callOnce(func, promiseKeeper, funcScope);\n  }\n\n  proxifyWithCache(func, funcName, funcScope) {\n    const proxified = this.proxify(func, funcName, funcScope);\n    return this.cacheRequest(proxified, funcName, funcScope);\n  }\n\n  _isExpired(cacheObject) {\n    if (cacheObject) {\n      const object_age = Date.now() - cacheObject.timestamp;\n      return !(cacheObject.timestamp && object_age < this.ttl);\n    } else {\n      return true;\n    }\n  }\n}\n\n/**\n * Wrap request to prevent multiple calls\n * with same params when waiting for result.\n */\nfunction callOnce(func, promiseKeeper, funcScope) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    const hash = getRequestHash(arguments);\n    if (!promiseKeeper[hash]) {\n      promiseKeeper[hash] = Promise.resolve(\n        func.apply(funcScope, arguments)\n        .then(result => {\n          promiseKeeper[hash] = null;\n          return result;\n        }).catch(err => {\n          promiseKeeper[hash] = null;\n          throw err;\n        })\n      );\n    }\n    return promiseKeeper[hash];\n  };\n}\n\nfunction cacheRequest(func, funcName, funcScope, self) {\n  // tslint:disable-next-line: only-arrow-functions\n  return function() {\n    if (!self.cache[funcName]) {\n      self.cache[funcName] = {};\n    }\n\n    const cacheObject = self.cache[funcName];\n    const hash = getRequestHash(arguments);\n    if (self.cacheEnabled && !self._isExpired(cacheObject[hash])) {\n      return Promise.resolve(cacheObject[hash].value);\n    } else {\n      return func.apply(funcScope, arguments)\n      .then(result => {\n        if (result !== undefined) {\n          cacheObject[hash] = {\n            value: result,\n            timestamp: Date.now()\n          };\n        }\n        return result;\n      });\n    }\n  };\n}\n\nfunction getRequestHash(args) {\n  const argsJson = JSON.stringify(args);\n  return getHash(argsJson);\n}\n\nfunction getHash(str: string): number {\n  let hash = 0, i, chr, len;\n  if (str.length !== 0) {\n    for (i = 0, len = str.length; i < len; i++) {\n      chr   = str.charCodeAt(i);\n      hash  = ((hash << 5) - hash) + chr;\n      hash |= 0; // Convert to 32bit integer\n    }\n  }\n  return hash;\n}\n","import _ from 'lodash';\nimport { getDataSourceSrv } from '@grafana/runtime';\n\nexport const DEFAULT_QUERY_LIMIT = 10000;\nexport const HISTORY_TO_TABLE_MAP = {\n  '0': 'history',\n  '1': 'history_str',\n  '2': 'history_log',\n  '3': 'history_uint',\n  '4': 'history_text'\n};\n\nexport const TREND_TO_TABLE_MAP = {\n  '0': 'trends',\n  '3': 'trends_uint'\n};\n\nexport const consolidateByFunc = {\n  'avg': 'AVG',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport const consolidateByTrendColumns = {\n  'avg': 'value_avg',\n  'min': 'value_min',\n  'max': 'value_max',\n  'sum': 'num*value_avg' // sum of sums inside the one-hour trend period\n};\n\n/**\n * Base class for external history database connectors. Subclasses should implement `getHistory()`, `getTrends()` and\n * `testDataSource()` methods, which describe how to fetch data from source other than Zabbix API.\n */\nexport class DBConnector {\n  constructor(options) {\n    this.datasourceId = options.datasourceId;\n    this.datasourceName = options.datasourceName;\n    this.datasourceTypeId = null;\n    this.datasourceTypeName = null;\n  }\n\n  static loadDatasource(dsId, dsName) {\n    if (!dsName && dsId !== undefined) {\n      let ds = _.find(getDataSourceSrv().getAll(), {'id': dsId});\n      if (!ds) {\n        return Promise.reject(`Data Source with ID ${dsId} not found`);\n      }\n      dsName = ds.name;\n    }\n    if (dsName) {\n      return getDataSourceSrv().loadDatasource(dsName);\n    } else {\n      return Promise.reject(`Data Source name should be specified`);\n    }\n  }\n\n  loadDBDataSource() {\n    return DBConnector.loadDatasource(this.datasourceId, this.datasourceName)\n    .then(ds => {\n      this.datasourceTypeId = ds.meta.id;\n      this.datasourceTypeName = ds.meta.name;\n      if (!this.datasourceName) {\n        this.datasourceName = ds.name;\n      }\n      if (!this.datasourceId) {\n        this.datasourceId = ds.id;\n      }\n      return ds;\n    });\n  }\n\n  /**\n   * Send test request to datasource in order to ensure it's working.\n   */\n  testDataSource() {\n    throw new ZabbixNotImplemented('testDataSource()');\n  }\n\n  /**\n   * Get history data from external sources.\n   */\n  getHistory() {\n    throw new ZabbixNotImplemented('getHistory()');\n  }\n\n  /**\n   * Get trends data from external sources.\n   */\n  getTrends() {\n    throw new ZabbixNotImplemented('getTrends()');\n  }\n\n  handleGrafanaTSResponse(history, items, addHostName = true) {\n    return convertGrafanaTSResponse(history, items, addHostName);\n  }\n}\n\n// Define Zabbix DB Connector exception type for non-implemented methods\nexport class ZabbixNotImplemented {\n  constructor(methodName) {\n    this.code = null;\n    this.name = 'ZabbixNotImplemented';\n    this.message = `Zabbix DB Connector Error: method ${methodName || ''} should be implemented in subclass of DBConnector`;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n\n/**\n * Converts time series returned by the data source into format that Grafana expects\n * time_series is Array of series:\n * ```\n * [{\n *     name: string,\n *     points: Array<[value: number, timestamp: number]>\n * }]\n * ```\n */\nfunction convertGrafanaTSResponse(time_series, items, addHostName) {\n  //uniqBy is needed to deduplicate\n  const hosts = _.uniqBy(_.flatten(_.map(items, 'hosts')), 'hostid');\n  let grafanaSeries = _.map(_.compact(time_series), series => {\n    const itemid = series.name;\n    const item = _.find(items, {'itemid': itemid});\n    let alias = item.name;\n\n    // Add scopedVars for using in alias functions\n    const scopedVars = {\n      '__zbx_item': { value: item.name },\n      '__zbx_item_name': { value: item.name },\n      '__zbx_item_key': { value: item.key_ },\n      '__zbx_item_interval': { value: item.delay },\n    };\n\n    if (_.keys(hosts).length > 0) {\n      const host = _.find(hosts, {'hostid': item.hostid});\n      scopedVars['__zbx_host'] = { value: host.host };\n      scopedVars['__zbx_host_name'] = { value: host.name };\n\n      // Only add host when multiple hosts selected\n      if (_.keys(hosts).length > 1 && addHostName) {\n        alias = host.name + \": \" + alias;\n      }\n    }\n    // CachingProxy deduplicates requests and returns one time series for equal queries.\n    // Clone is needed to prevent changing of series object shared between all targets.\n    const datapoints = _.cloneDeep(series.points);\n    return {\n      target: alias,\n      datapoints,\n      scopedVars,\n      item\n    };\n  });\n\n  return _.sortBy(grafanaSeries, 'target');\n}\n\nconst defaults = {\n  DBConnector,\n  DEFAULT_QUERY_LIMIT,\n  HISTORY_TO_TABLE_MAP,\n  TREND_TO_TABLE_MAP,\n  consolidateByFunc,\n  consolidateByTrendColumns\n};\n\nexport default defaults;\n","import _ from 'lodash';\nimport semver from 'semver';\nimport kbn from 'grafana/app/core/utils/kbn';\nimport * as utils from '../../../utils';\nimport { ZBX_ACK_ACTION_NONE, ZBX_ACK_ACTION_ADD_MESSAGE, MIN_SLA_INTERVAL } from '../../../constants';\nimport { ShowProblemTypes, ZBXProblem } from '../../../types';\nimport { JSONRPCError, ZBXScript, APIExecuteScriptResponse } from './types';\nimport { BackendSrvRequest, getBackendSrv } from '@grafana/runtime';\nimport { rangeUtil } from '@grafana/data';\n\nconst DEFAULT_ZABBIX_VERSION = '3.0.0';\n\n// Backward compatibility. Since Grafana 7.2 roundInterval() func was moved to @grafana/data package\nconst roundInterval: (interval: number) => number = rangeUtil?.roundInterval || kbn.roundInterval || kbn.round_interval;\n\n/**\n * Zabbix API Wrapper.\n * Creates Zabbix API instance with given parameters (url, credentials and other).\n * Wraps API calls and provides high-level methods.\n */\nexport class ZabbixAPIConnector {\n  backendAPIUrl: string;\n  requestOptions: { basicAuth: any; withCredentials: boolean; };\n  getTrend: (items: any, timeFrom: any, timeTill: any) => Promise<any[]>;\n  version: string;\n  getVersionPromise: Promise<string>;\n  datasourceId: number;\n\n  constructor(basicAuth: any, withCredentials: boolean, datasourceId: number) {\n    this.datasourceId = datasourceId;\n    this.backendAPIUrl = `/api/datasources/${this.datasourceId}/resources/zabbix-api`;\n\n    this.requestOptions = {\n      basicAuth: basicAuth,\n      withCredentials: withCredentials\n    };\n\n    this.getTrend = this.getTrend_ZBXNEXT1193;\n    //getTrend = getTrend_30;\n\n    this.initVersion();\n  }\n\n  //////////////////////////\n  // Core method wrappers //\n  //////////////////////////\n\n  request(method: string, params?: any) {\n    return this.backendAPIRequest(method, params).then(response => {\n      return response?.data?.result;\n    });\n  }\n\n  backendAPIRequest(method: string, params: any = {}) {\n    const requestOptions: BackendSrvRequest = {\n      url: this.backendAPIUrl,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      hideFromInspector: false,\n      data: {\n        datasourceId: this.datasourceId,\n        method,\n        params,\n      },\n    };\n\n    // Set request options for basic auth\n    if (this.requestOptions.basicAuth || this.requestOptions.withCredentials) {\n      requestOptions.withCredentials = true;\n    }\n    if (this.requestOptions.basicAuth) {\n      requestOptions.headers.Authorization = this.requestOptions.basicAuth;\n    }\n\n    return getBackendSrv().datasourceRequest(requestOptions);\n  }\n\n  /**\n   * Get Zabbix API version\n   */\n  getVersion() {\n    return this.request('apiinfo.version');\n  }\n\n  initVersion(): Promise<string> {\n    if (!this.getVersionPromise) {\n      this.getVersionPromise = Promise.resolve(\n        this.getVersion().then(version => {\n          if (version) {\n            console.log(`Zabbix version detected: ${version}`);\n          } else {\n            console.log(`Failed to detect Zabbix version, use default ${DEFAULT_ZABBIX_VERSION}`);\n          }\n\n          this.version = version || DEFAULT_ZABBIX_VERSION;\n          this.getVersionPromise = null;\n          return version;\n        })\n      );\n    }\n    return this.getVersionPromise;\n  }\n\n  ////////////////////////////////\n  // Zabbix API method wrappers //\n  ////////////////////////////////\n\n  acknowledgeEvent(eventid: string, message: string, action?: number, severity?: number) {\n    if (!action) {\n      action = semver.gte(this.version, '4.0.0') ? ZBX_ACK_ACTION_ADD_MESSAGE : ZBX_ACK_ACTION_NONE;\n    }\n\n    const params: any = {\n      eventids: eventid,\n      message: message,\n      action: action\n    };\n\n    if (severity !== undefined) {\n      params.severity = severity;\n    }\n\n    return this.request('event.acknowledge', params);\n  }\n\n  getGroups() {\n    const params = {\n      output: ['name'],\n      sortfield: 'name',\n      real_hosts: true\n    };\n\n    return this.request('hostgroup.get', params);\n  }\n\n  getHosts(groupids) {\n    const params: any = {\n      output: ['name', 'host'],\n      sortfield: 'name'\n    };\n    if (groupids) {\n      params.groupids = groupids;\n    }\n\n    return this.request('host.get', params);\n  }\n\n  getApps(hostids): Promise<any[]> {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('application.get', params);\n  }\n\n  /**\n   * Get Zabbix items\n   * @param  {[type]} hostids  host ids\n   * @param  {[type]} appids   application ids\n   * @param  {String} itemtype 'num' or 'text'\n   * @return {[type]}          array of items\n   */\n  getItems(hostids, appids, itemtype) {\n    const params: any = {\n      output: [\n        'name',\n        'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state',\n        'units',\n        'valuemapid',\n        'delay'\n      ],\n      sortfield: 'name',\n      webitems: true,\n      filter: {},\n      selectHosts: ['hostid', 'name', 'host']\n    };\n    if (hostids) {\n      params.hostids = hostids;\n    }\n    if (appids) {\n      params.applicationids = appids;\n    }\n    if (itemtype === 'num') {\n      // Return only numeric metrics\n      params.filter.value_type = [0, 3];\n    }\n    if (itemtype === 'text') {\n      // Return only text metrics\n      params.filter.value_type = [1, 2, 4];\n    }\n\n    return this.request('item.get', params)\n    .then(utils.expandItems);\n  }\n\n  getItemsByIDs(itemids) {\n    const params = {\n      itemids: itemids,\n      output: [\n        'name',\n        'key_',\n        'value_type',\n        'hostid',\n        'status',\n        'state',\n        'units',\n        'valuemapid',\n        'delay'\n      ],\n      webitems: true,\n      selectHosts: ['hostid', 'name']\n    };\n\n    return this.request('item.get', params)\n    .then(items => utils.expandItems(items));\n  }\n\n  getMacros(hostids) {\n    const params = {\n      output: 'extend',\n      hostids: hostids\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getGlobalMacros() {\n    const params = {\n      output: 'extend',\n      globalmacro: true\n    };\n\n    return this.request('usermacro.get', params);\n  }\n\n  getLastValue(itemid) {\n    const params = {\n      output: ['lastvalue'],\n      itemids: itemid\n    };\n    return this.request('item.get', params)\n    .then(items => items.length ? items[0].lastvalue : null);\n  }\n\n  /**\n   * Perform history query from Zabbix API\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} timeFrom   Time in seconds\n   * @param  {Number} timeTill   Time in seconds\n   * @return {Array}  Array of Zabbix history objects\n   */\n  getHistory(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        history: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('history.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  /**\n   * Perform trends query from Zabbix API\n   * Use trends api extension from ZBXNEXT-1193 patch.\n   *\n   * @param  {Array}  items       Array of Zabbix item objects\n   * @param  {Number} time_from   Time in seconds\n   * @param  {Number} time_till   Time in seconds\n   * @return {Array}  Array of Zabbix trend objects\n   */\n  getTrend_ZBXNEXT1193(items, timeFrom, timeTill) {\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const params: any = {\n        output: 'extend',\n        trend: value_type,\n        itemids: itemids,\n        sortfield: 'clock',\n        sortorder: 'ASC',\n        time_from: timeFrom\n      };\n\n      // Relative queries (e.g. last hour) don't include an end time\n      if (timeTill) {\n        params.time_till = timeTill;\n      }\n\n      return this.request('trend.get', params);\n    });\n\n    return Promise.all(promises).then(_.flatten);\n  }\n\n  getTrend_30(items, time_from, time_till, value_type) {\n    const self = this;\n    const itemids = _.map(items, 'itemid');\n\n    const params: any = {\n      output: [\"itemid\",\n        \"clock\",\n        value_type\n      ],\n      itemids: itemids,\n      time_from: time_from\n    };\n\n    // Relative queries (e.g. last hour) don't include an end time\n    if (time_till) {\n      params.time_till = time_till;\n    }\n\n    return self.request('trend.get', params);\n  }\n\n  getITService(serviceids?) {\n    const params = {\n      output: 'extend',\n      serviceids: serviceids\n    };\n    return this.request('service.get', params);\n  }\n\n  getSLA(serviceids, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    let intervals = [{ from: timeFrom, to: timeTo }];\n    if (options.slaInterval === 'auto') {\n      const interval = getSLAInterval(options.intervalMs);\n      intervals = buildSLAIntervals(timeRange, interval);\n    } else if (options.slaInterval !== 'none') {\n      const interval = utils.parseInterval(options.slaInterval) / 1000;\n      intervals = buildSLAIntervals(timeRange, interval);\n    }\n\n    const params: any = {\n      serviceids,\n      intervals\n    };\n\n    return this.request('service.getsla', params);\n  }\n\n  getProblems(groupids, hostids, applicationids, options): Promise<ZBXProblem[]> {\n    const { timeFrom, timeTo, recent, severities, limit, acknowledged, tags } = options;\n\n    const params: any = {\n      output: 'extend',\n      selectAcknowledges: 'extend',\n      selectSuppressionData: 'extend',\n      selectTags: 'extend',\n      source: '0',\n      object: '0',\n      sortfield: ['eventid'],\n      sortorder: 'DESC',\n      evaltype: '0',\n      // preservekeys: '1',\n      groupids,\n      hostids,\n      applicationids,\n      recent,\n    };\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (acknowledged !== undefined) {\n      params.acknowledged = acknowledged;\n    }\n\n    if (tags) {\n      params.tags = tags;\n    }\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (timeFrom || timeTo) {\n      params.time_from = timeFrom;\n      params.time_till = timeTo;\n    }\n\n    return this.request('problem.get', params).then(utils.mustArray);\n  }\n\n  getTriggersByIds(triggerids: string[]) {\n    const params: any = {\n      output: 'extend',\n      triggerids: triggerids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      // selectLastEvent: 'extend',\n      // selectTags: 'extend',\n      preservekeys: '1',\n    };\n\n    return this.request('trigger.get', params).then(utils.mustArray);\n  }\n\n  getTriggers(groupids, hostids, applicationids, options) {\n    const {showTriggers, maintenance, timeFrom, timeTo} = options;\n\n    const params: any = {\n      output: 'extend',\n      groupids: groupids,\n      hostids: hostids,\n      applicationids: applicationids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      filter: {\n        value: 1\n      },\n      selectGroups: ['name'],\n      selectHosts: ['name', 'host', 'maintenance_status', 'proxy_hostid'],\n      selectItems: ['name', 'key_', 'lastvalue'],\n      selectLastEvent: 'extend',\n      selectTags: 'extend'\n    };\n\n    if (showTriggers === ShowProblemTypes.Problems) {\n      params.filter.value = 1;\n    } else if (showTriggers === ShowProblemTypes.Recent || showTriggers === ShowProblemTypes.History) {\n      params.filter.value = [0, 1];\n    }\n\n    if (maintenance) {\n      params.maintenance = true;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getEvents(objectids, timeFrom, timeTo, showEvents, limit) {\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      objectids: objectids,\n      select_acknowledges: 'extend',\n      selectHosts: 'extend',\n      value: showEvents,\n    };\n\n    if (limit) {\n      params.limit = limit;\n      params.sortfield = 'clock';\n      params.sortorder = 'DESC';\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getEventsHistory(groupids, hostids, applicationids, options) {\n    const { timeFrom, timeTo, severities, limit, value } = options;\n\n    const params: any = {\n      output: 'extend',\n      time_from: timeFrom,\n      time_till: timeTo,\n      value: '1',\n      source: '0',\n      object: '0',\n      evaltype: '0',\n      sortfield: ['eventid'],\n      sortorder: 'DESC',\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      selectSuppressionData: ['maintenanceid', 'suppress_until'],\n      groupids,\n      hostids,\n      applicationids,\n    };\n\n    if (limit) {\n      params.limit = limit;\n    }\n\n    if (severities) {\n      params.severities = severities;\n    }\n\n    if (value) {\n      params.value = value;\n    }\n\n    return this.request('event.get', params).then(utils.mustArray);\n  }\n\n  getExtendedEventData(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      selectTags: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params);\n  }\n\n  getEventAlerts(eventids) {\n    const params = {\n      eventids: eventids,\n      output: [\n        'eventid',\n        'message',\n        'clock',\n        'error'\n      ],\n      selectUsers: true,\n    };\n\n    return this.request('alert.get', params);\n  }\n\n  getAcknowledges(eventids) {\n    const params = {\n      output: 'extend',\n      eventids: eventids,\n      preservekeys: true,\n      select_acknowledges: 'extend',\n      sortfield: 'clock',\n      sortorder: 'DESC'\n    };\n\n    return this.request('event.get', params)\n    .then(events => {\n      return _.filter(events, (event) => event.acknowledges.length);\n    });\n  }\n\n  getAlerts(itemids, timeFrom, timeTo) {\n    const params: any = {\n      output: 'extend',\n      itemids: itemids,\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      //only_true: true,\n      // filter: {\n      //   value: 1\n      // },\n      selectLastEvent: 'extend'\n    };\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params);\n  }\n\n  getHostAlerts(hostids, applicationids, options) {\n    const {minSeverity, acknowledged, count, timeFrom, timeTo} = options;\n    const params: any = {\n      output: 'extend',\n      hostids: hostids,\n      min_severity: minSeverity,\n      filter: { value: 1 },\n      expandDescription: true,\n      expandData: true,\n      expandComment: true,\n      monitored: true,\n      skipDependent: true,\n      selectLastEvent: 'extend',\n      selectGroups: 'extend',\n      selectHosts: ['host', 'name']\n    };\n\n    if (count && acknowledged !== 0 && acknowledged !== 1) {\n      params.countOutput = true;\n    }\n\n    if (applicationids && applicationids.length) {\n      params.applicationids = applicationids;\n    }\n\n    if (timeFrom || timeTo) {\n      params.lastChangeSince = timeFrom;\n      params.lastChangeTill = timeTo;\n    }\n\n    return this.request('trigger.get', params)\n    .then((triggers) => {\n      if (!count || acknowledged === 0 || acknowledged === 1) {\n        triggers = filterTriggersByAcknowledge(triggers, acknowledged);\n        if (count) {\n          triggers = triggers.length;\n        }\n      }\n      return triggers;\n    });\n  }\n\n  getProxies() {\n    const params = {\n      output: ['proxyid', 'host'],\n    };\n\n    return this.request('proxy.get', params);\n  }\n\n  getScripts(hostids: string[], options?: any): Promise<ZBXScript[]> {\n    const params: any = {\n      output: 'extend',\n      hostids,\n    };\n\n    return this.request('script.get', params).then(utils.mustArray);\n  }\n\n  executeScript(hostid: string, scriptid: string): Promise<APIExecuteScriptResponse> {\n    const params: any = {\n      hostid,\n      scriptid,\n    };\n\n    return this.request('script.execute', params);\n  }\n\n  getValueMappings() {\n    const params = {\n      output: 'extend',\n      selectMappings: \"extend\",\n    };\n\n    return this.request('valuemap.get', params);\n  }\n}\n\nfunction filterTriggersByAcknowledge(triggers, acknowledged) {\n  if (acknowledged === 0) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"0\");\n  } else if (acknowledged === 1) {\n    return _.filter(triggers, (trigger) => trigger.lastEvent.acknowledged === \"1\");\n  } else {\n    return triggers;\n  }\n}\n\nfunction getSLAInterval(intervalMs) {\n  // Too many intervals may cause significant load on the database, so decrease number of resulting points\n  const resolutionRatio = 100;\n  const interval = roundInterval(intervalMs * resolutionRatio) / 1000;\n  return Math.max(interval, MIN_SLA_INTERVAL);\n}\n\nfunction buildSLAIntervals(timeRange, interval) {\n  let [timeFrom, timeTo] = timeRange;\n  const intervals = [];\n\n  // Align time range with calculated interval\n  timeFrom = Math.floor(timeFrom / interval) * interval;\n  timeTo = Math.ceil(timeTo / interval) * interval;\n\n  for (let i = timeFrom; i <= timeTo - interval; i += interval) {\n    intervals.push({\n      from : i,\n      to : (i + interval)\n    });\n\n  }\n\n  return intervals;\n}\n\n// Define zabbix API exception type\nexport class ZabbixAPIError {\n  code: number;\n  name: string;\n  data: string;\n  message: string;\n\n  constructor(error: JSONRPCError) {\n    this.code = error.code || null;\n    this.name = error.message || \"\";\n    this.data = error.data || \"\";\n    this.message = \"Zabbix API Error: \" + this.name + \" \" + this.data;\n  }\n\n  toString() {\n    return this.name + \" \" + this.data;\n  }\n}\n","/**\n * MySQL queries\n */\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let query = `\n    SELECT CAST(itemid AS CHAR) AS metric, MIN(clock) AS time_sec, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY (clock-${timeFrom}) DIV ${intervalSec}, metric\n    ORDER BY time_sec ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `SELECT CAST(itemid AS CHAR) AS metric, clock AS time_sec, value_avg AS value FROM trends_uint LIMIT 1`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst mysql = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default mysql;\n","/**\n * Postgres queries\n */\n\nconst ITEMID_FORMAT = 'FM99999999999999999999';\n\nfunction historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(value) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nfunction trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn) {\n  let time_expression = `clock / ${intervalSec} * ${intervalSec}`;\n  let query = `\n    SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, ${time_expression} AS time, ${aggFunction}(${valueColumn}) AS value\n    FROM ${table}\n    WHERE itemid IN (${itemids})\n      AND clock > ${timeFrom} AND clock < ${timeTill}\n    GROUP BY 1, 2\n    ORDER BY time ASC\n  `;\n  return query;\n}\n\nconst TEST_QUERY = `\n  SELECT to_char(itemid, '${ITEMID_FORMAT}') AS metric, clock AS time, value_avg AS value\n  FROM trends_uint LIMIT 1\n`;\n\nfunction testQuery() {\n  return TEST_QUERY;\n}\n\nconst postgres = {\n  historyQuery,\n  trendsQuery,\n  testQuery\n};\n\nexport default postgres;\n","import _ from 'lodash';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { compactQuery } from '../../../utils';\nimport mysql from './mysql';\nimport postgres from './postgres';\nimport dbConnector, { DBConnector, DEFAULT_QUERY_LIMIT, HISTORY_TO_TABLE_MAP, TREND_TO_TABLE_MAP } from '../dbConnector';\n\nconst supportedDatabases = {\n  mysql: 'mysql',\n  postgres: 'postgres'\n};\n\nexport class SQLConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n\n    this.limit = options.limit || DEFAULT_QUERY_LIMIT;\n    this.sqlDialect = null;\n\n    super.loadDBDataSource()\n    .then(() => {\n      this.loadSQLDialect();\n    });\n  }\n\n  loadSQLDialect() {\n    if (this.datasourceTypeId === supportedDatabases.postgres) {\n      this.sqlDialect = postgres;\n    } else {\n      this.sqlDialect = mysql;\n    }\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    let testQuery = this.sqlDialect.testQuery();\n    return this.invokeSQLQuery(testQuery);\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let {intervalMs, consolidateBy} = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = HISTORY_TO_TABLE_MAP[value_type];\n      let query = this.sqlDialect.historyQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy } = options;\n    let intervalSec = Math.ceil(intervalMs / 1000);\n\n    // The interval must match the time range exactly n times, otherwise\n    // the resulting first and last data points will yield invalid values in the\n    // calculated average value in downsampleSeries - when using consolidateBy(avg)\n    let numOfIntervals = Math.ceil((timeTill - timeFrom) / intervalSec);\n    intervalSec = (timeTill - timeFrom) / numOfIntervals;\n\n    consolidateBy = consolidateBy || 'avg';\n    let aggFunction = dbConnector.consolidateByFunc[consolidateBy];\n\n    // Group items by value type and perform request for each value type\n    let grouped_items = _.groupBy(items, 'value_type');\n    let promises = _.map(grouped_items, (items, value_type) => {\n      let itemids = _.map(items, 'itemid').join(', ');\n      let table = TREND_TO_TABLE_MAP[value_type];\n      let valueColumn = _.includes(['avg', 'min', 'max', 'sum'], consolidateBy) ? consolidateBy : 'avg';\n      valueColumn = dbConnector.consolidateByTrendColumns[valueColumn];\n      let query = this.sqlDialect.trendsQuery(itemids, table, timeFrom, timeTill, intervalSec, aggFunction, valueColumn);\n\n      query = compactQuery(query);\n      return this.invokeSQLQuery(query);\n    });\n\n    return Promise.all(promises).then(results => {\n      return _.flatten(results);\n    });\n  }\n\n  invokeSQLQuery(query) {\n    let queryDef = {\n      refId: 'A',\n      format: 'time_series',\n      datasourceId: this.datasourceId,\n      rawSql: query,\n      maxDataPoints: this.limit\n    };\n\n    return getBackendSrv().datasourceRequest({\n      url: '/api/tsdb/query',\n      method: 'POST',\n      data: {\n        queries: [queryDef],\n      }\n    })\n    .then(response => {\n      let results = response.data.results;\n      if (results['A']) {\n        return results['A'].series;\n      } else {\n        return null;\n      }\n    });\n  }\n}\n","import _ from 'lodash';\nimport { compactQuery } from '../../../utils';\nimport { DBConnector, HISTORY_TO_TABLE_MAP, consolidateByTrendColumns } from '../dbConnector';\n\nconst consolidateByFunc = {\n  'avg': 'MEAN',\n  'min': 'MIN',\n  'max': 'MAX',\n  'sum': 'SUM',\n  'count': 'COUNT'\n};\n\nexport class InfluxDBConnector extends DBConnector {\n  constructor(options) {\n    super(options);\n    this.retentionPolicy = options.retentionPolicy;\n    super.loadDBDataSource().then(ds => {\n      this.influxDS = ds;\n      return ds;\n    });\n  }\n\n  /**\n   * Try to invoke test query for one of Zabbix database tables.\n   */\n  testDataSource() {\n    return this.influxDS.testDatasource().then(result => {\n      if (result.status && result.status === 'error') {\n        return Promise.reject({ data: {\n          message: `InfluxDB connection error: ${result.message}`\n        }});\n      }\n      return result;\n    });\n  }\n\n  getHistory(items, timeFrom, timeTill, options) {\n    let { intervalMs, consolidateBy, retentionPolicy } = options;\n    const intervalSec = Math.ceil(intervalMs / 1000);\n\n    const range = { timeFrom, timeTill };\n    consolidateBy = consolidateBy || 'avg';\n\n    // Group items by value type and perform request for each value type\n    const grouped_items = _.groupBy(items, 'value_type');\n    const promises = _.map(grouped_items, (items, value_type) => {\n      const itemids = _.map(items, 'itemid');\n      const table = HISTORY_TO_TABLE_MAP[value_type];\n      const query = this.buildHistoryQuery(itemids, table, range, intervalSec, consolidateBy, retentionPolicy);\n      return this.invokeInfluxDBQuery(query);\n    });\n\n    return Promise.all(promises)\n    .then(_.flatten)\n    .then(results => {\n      return handleInfluxHistoryResponse(results);\n    });\n  }\n\n  getTrends(items, timeFrom, timeTill, options) {\n    options.retentionPolicy = this.retentionPolicy;\n    return this.getHistory(items, timeFrom, timeTill, options);\n  }\n\n  buildHistoryQuery(itemids, table, range, intervalSec, aggFunction, retentionPolicy) {\n    const { timeFrom, timeTill } = range;\n    const measurement = retentionPolicy ? `\"${retentionPolicy}\".\"${table}\"` : `\"${table}\"`;\n    let value = 'value';\n    if (retentionPolicy) {\n      value = consolidateByTrendColumns[aggFunction] || 'value_avg';\n    }\n    const aggregation = consolidateByFunc[aggFunction] || aggFunction;\n    const where_clause = this.buildWhereClause(itemids);\n    const query = `SELECT ${aggregation}(\"${value}\") FROM ${measurement}\n      WHERE ${where_clause} AND \"time\" >= ${timeFrom}s AND \"time\" <= ${timeTill}s\n      GROUP BY time(${intervalSec}s), \"itemid\" fill(none)`;\n    return compactQuery(query);\n  }\n\n  buildWhereClause(itemids) {\n    const itemidsWhere = itemids.map(itemid => `\"itemid\" = '${itemid}'`).join(' OR ');\n    return `(${itemidsWhere})`;\n  }\n\n  invokeInfluxDBQuery(query) {\n    return this.influxDS._seriesQuery(query)\n    .then(data => data && data.results ? data.results : []);\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nfunction handleInfluxHistoryResponse(results) {\n  if (!results) {\n    return [];\n  }\n\n  const seriesList = [];\n  for (let i = 0; i < results.length; i++) {\n    const result = results[i];\n\n    if (result.error) {\n      const error = `InfluxDB error: ${result.error}`;\n      return Promise.reject(new Error(error));\n    }\n\n    if (!result || !result.series) {\n      continue;\n    }\n\n    const influxSeriesList = results[i].series;\n\n    for (let y = 0; y < influxSeriesList.length; y++) {\n      const influxSeries = influxSeriesList[y];\n      const datapoints = [];\n      if (influxSeries.values) {\n        for (i = 0; i < influxSeries.values.length; i++) {\n          datapoints[i] = [influxSeries.values[i][1], influxSeries.values[i][0]];\n        }\n      }\n      const timeSeries = {\n        name: influxSeries.tags.itemid,\n        points: datapoints\n      };\n      seriesList.push(timeSeries);\n    }\n  }\n\n  return seriesList;\n}\n","import _ from 'lodash';\nimport moment from 'moment';\nimport * as utils from '../utils';\nimport responseHandler from '../responseHandler';\nimport { CachingProxy } from './proxy/cachingProxy';\n// import { ZabbixNotImplemented } from './connectors/dbConnector';\nimport { DBConnector } from './connectors/dbConnector';\nimport { ZabbixAPIConnector } from './connectors/zabbix_api/zabbixAPIConnector';\nimport { SQLConnector } from './connectors/sql/sqlConnector';\nimport { InfluxDBConnector } from './connectors/influxdb/influxdbConnector';\nimport { ZabbixConnector } from './types';\nimport { joinTriggersWithProblems, joinTriggersWithEvents } from '../problemsHandler';\nimport { ProblemDTO } from '../types';\n\ninterface AppsResponse extends Array<any> {\n  appFilterEmpty?: boolean;\n  hostids?: any[];\n}\n\nconst REQUESTS_TO_PROXYFY = [\n  'getHistory', 'getTrend', 'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs',\n  'getEvents', 'getAlerts', 'getHostAlerts', 'getAcknowledges', 'getITService', 'getSLA', 'getVersion', 'getProxies',\n  'getEventAlerts', 'getExtendedEventData', 'getProblems', 'getEventsHistory', 'getTriggersByIds', 'getScripts', 'getValueMappings'\n];\n\nconst REQUESTS_TO_CACHE = [\n  'getGroups', 'getHosts', 'getApps', 'getItems', 'getMacros', 'getItemsByIDs', 'getITService', 'getProxies', 'getValueMappings'\n];\n\nconst REQUESTS_TO_BIND = [\n  'getHistory', 'getTrend', 'getMacros', 'getItemsByIDs', 'getEvents', 'getAlerts', 'getHostAlerts',\n  'getAcknowledges', 'getITService', 'getVersion', 'acknowledgeEvent', 'getProxies', 'getEventAlerts',\n  'getExtendedEventData', 'getScripts', 'executeScript', 'getValueMappings'\n];\n\nexport class Zabbix implements ZabbixConnector {\n  enableDirectDBConnection: boolean;\n  cachingProxy: CachingProxy;\n  zabbixAPI: ZabbixAPIConnector;\n  getHistoryDB: any;\n  dbConnector: any;\n  getTrendsDB: any;\n\n  getHistory: (items, timeFrom, timeTill) => Promise<any>;\n  getTrend: (items, timeFrom, timeTill) => Promise<any>;\n  getItemsByIDs: (itemids) => Promise<any>;\n  getEvents: (objectids, timeFrom, timeTo, showEvents, limit?) => Promise<any>;\n  getAlerts: (itemids, timeFrom?, timeTo?) => Promise<any>;\n  getHostAlerts: (hostids, applicationids, options?) => Promise<any>;\n  getAcknowledges: (eventids) => Promise<any>;\n  getITService: (serviceids?) => Promise<any>;\n  acknowledgeEvent: (eventid, message) => Promise<any>;\n  getProxies: () => Promise<any>;\n  getEventAlerts: (eventids) => Promise<any>;\n  getExtendedEventData: (eventids) => Promise<any>;\n  getMacros: (hostids: any[]) => Promise<any>;\n  getVersion: () => Promise<string>;\n  getValueMappings: () => Promise<any>;\n\n  constructor(options) {\n    const {\n      basicAuth,\n      withCredentials,\n      cacheTTL,\n      enableDirectDBConnection,\n      dbConnectionDatasourceId,\n      dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy,\n      datasourceId,\n    } = options;\n\n    this.enableDirectDBConnection = enableDirectDBConnection;\n\n    // Initialize caching proxy for requests\n    const cacheOptions = {\n      enabled: true,\n      ttl: cacheTTL\n    };\n    this.cachingProxy = new CachingProxy(cacheOptions);\n\n    this.zabbixAPI = new ZabbixAPIConnector(basicAuth, withCredentials, datasourceId);\n\n    this.proxifyRequests();\n    this.cacheRequests();\n    this.bindRequests();\n\n    if (enableDirectDBConnection) {\n      const connectorOptions: any = { dbConnectionRetentionPolicy };\n      this.initDBConnector(dbConnectionDatasourceId, dbConnectionDatasourceName, connectorOptions)\n      .then(() => {\n        this.getHistoryDB = this.cachingProxy.proxifyWithCache(this.dbConnector.getHistory, 'getHistory', this.dbConnector);\n        this.getTrendsDB = this.cachingProxy.proxifyWithCache(this.dbConnector.getTrends, 'getTrends', this.dbConnector);\n      });\n    }\n  }\n\n  initDBConnector(datasourceId, datasourceName, options) {\n    return DBConnector.loadDatasource(datasourceId, datasourceName)\n    .then(ds => {\n      const connectorOptions: any = { datasourceId, datasourceName };\n      if (ds.type === 'influxdb') {\n        connectorOptions.retentionPolicy = options.dbConnectionRetentionPolicy;\n        this.dbConnector = new InfluxDBConnector(connectorOptions);\n      } else {\n        this.dbConnector = new SQLConnector(connectorOptions);\n      }\n      return this.dbConnector;\n    });\n  }\n\n  proxifyRequests() {\n    for (const request of REQUESTS_TO_PROXYFY) {\n      this.zabbixAPI[request] = this.cachingProxy.proxify(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  cacheRequests() {\n    for (const request of REQUESTS_TO_CACHE) {\n      this.zabbixAPI[request] = this.cachingProxy.cacheRequest(this.zabbixAPI[request], request, this.zabbixAPI);\n    }\n  }\n\n  bindRequests() {\n    for (const request of REQUESTS_TO_BIND) {\n      this[request] = this.zabbixAPI[request].bind(this.zabbixAPI);\n    }\n  }\n\n  /**\n   * Perform test query for Zabbix API and external history DB.\n   * @return {object} test result object:\n   * ```\n   *    {\n   *      zabbixVersion,\n   *      dbConnectorStatus: {\n   *        dsType,\n   *        dsName\n   *      }\n   *    }\n   * ```\n   */\n  testDataSource() {\n    let zabbixVersion;\n    let dbConnectorStatus;\n    return this.getVersion()\n    .then(version => {\n      zabbixVersion = version;\n      return this.getAllGroups();\n    })\n    .then(() => {\n      if (this.enableDirectDBConnection) {\n        return this.dbConnector.testDataSource();\n      } else {\n        return Promise.resolve();\n      }\n    })\n    .catch(error => {\n      return Promise.reject(error);\n    })\n    .then(testResult => {\n      if (testResult) {\n        dbConnectorStatus = {\n          dsType: this.dbConnector.datasourceTypeName,\n          dsName: this.dbConnector.datasourceName\n        };\n      }\n      return { zabbixVersion, dbConnectorStatus };\n    });\n  }\n\n  getItemsFromTarget(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    const filters = _.map(parts, p => target[p].filter);\n    return this.getItems(...filters, options);\n  }\n\n  getHostsFromTarget(target) {\n    const parts = ['group', 'host', 'application'];\n    const filters = _.map(parts, p => target[p].filter);\n    return Promise.all([\n      this.getHosts(...filters),\n      this.getApps(...filters),\n    ]).then(results => {\n      const hosts = results[0];\n      let apps: AppsResponse = results[1];\n      if (apps.appFilterEmpty) {\n        apps = [];\n      }\n      return [hosts, apps];\n    });\n  }\n\n  getAllGroups() {\n    return this.zabbixAPI.getGroups();\n  }\n\n  getGroups(groupFilter) {\n    return this.getAllGroups()\n    .then(groups => findByFilter(groups, groupFilter));\n  }\n\n  /**\n   * Get list of host belonging to given groups.\n   */\n  getAllHosts(groupFilter) {\n    return this.getGroups(groupFilter)\n    .then(groups => {\n      const groupids = _.map(groups, 'groupid');\n      return this.zabbixAPI.getHosts(groupids);\n    });\n  }\n\n  getHosts(groupFilter?, hostFilter?) {\n    return this.getAllHosts(groupFilter)\n    .then(hosts => findByFilter(hosts, hostFilter));\n  }\n\n  /**\n   * Get list of applications belonging to given groups and hosts.\n   */\n  getAllApps(groupFilter, hostFilter) {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      return this.zabbixAPI.getApps(hostids);\n    });\n  }\n\n  getApps(groupFilter?, hostFilter?, appFilter?): Promise<AppsResponse> {\n    return this.getHosts(groupFilter, hostFilter)\n    .then(hosts => {\n      const hostids = _.map(hosts, 'hostid');\n      if (appFilter) {\n        return this.zabbixAPI.getApps(hostids)\n        .then(apps => filterByQuery(apps, appFilter));\n      } else {\n        const appsResponse: AppsResponse = hostids;\n        appsResponse.hostids = hostids;\n        appsResponse.appFilterEmpty = true;\n        return Promise.resolve(appsResponse);\n      }\n    });\n  }\n\n  getAllItems(groupFilter, hostFilter, appFilter, options: any = {}) {\n    return this.getApps(groupFilter, hostFilter, appFilter)\n    .then(apps => {\n      if (apps.appFilterEmpty) {\n        return this.zabbixAPI.getItems(apps.hostids, undefined, options.itemtype);\n      } else {\n        const appids = _.map(apps, 'applicationid');\n        return this.zabbixAPI.getItems(undefined, appids, options.itemtype);\n      }\n    })\n    .then(items => {\n      if (!options.showDisabledItems) {\n        items = _.filter(items, {'status': '0'});\n      }\n\n      return items;\n    })\n    .then(this.expandUserMacro.bind(this));\n  }\n\n  expandUserMacro(items, isTriggerItem) {\n    const hostids = getHostIds(items);\n    return this.getMacros(hostids)\n    .then(macros => {\n      _.forEach(items, item => {\n        if (utils.containsMacro(isTriggerItem ? item.url : item.name)) {\n          if (isTriggerItem) {\n            item.url = utils.replaceMacro(item, macros, isTriggerItem);\n          } else {\n            item.name = utils.replaceMacro(item, macros);\n          }\n        }\n      });\n      return items;\n    });\n  }\n\n  getItems(groupFilter?, hostFilter?, appFilter?, itemFilter?, options = {}) {\n    return this.getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => filterByQuery(items, itemFilter));\n  }\n\n  getItemValues(groupFilter?, hostFilter?, appFilter?, itemFilter?, options: any = {}) {\n    return this.getItems(groupFilter, hostFilter, appFilter, itemFilter, options).then(items => {\n      let timeRange = [moment().subtract(2, 'h').unix(), moment().unix()];\n      if (options.range) {\n        timeRange = [options.range.from.unix(), options.range.to.unix()];\n      }\n      const [timeFrom, timeTo] = timeRange;\n\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo).then(history => {\n        if (history) {\n          const values = _.uniq(history.map(v => v.value));\n          return values.map(value => ({ name: value }));\n        } else {\n          return [];\n        }\n      });\n    });\n  }\n\n  getITServices(itServiceFilter) {\n    return this.zabbixAPI.getITService()\n    .then(itServices => findByFilter(itServices, itServiceFilter));\n  }\n\n  getProblems(groupFilter, hostFilter, appFilter, proxyFilter?, options?): Promise<ProblemDTO[]> {\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter && hostFilter !== '/.*/') {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getProblems(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([\n        Promise.resolve(problems),\n        this.zabbixAPI.getTriggersByIds(triggerids)\n      ]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithProblems(problems, triggers))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n    // .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter?, options?): Promise<ProblemDTO[]> {\n    const { valueFromEvent } = options;\n\n    const promises = [\n      this.getGroups(groupFilter),\n      this.getHosts(groupFilter, hostFilter),\n      this.getApps(groupFilter, hostFilter, appFilter)\n    ];\n\n    return Promise.all(promises)\n    .then(results => {\n      const [filteredGroups, filteredHosts, filteredApps] = results;\n      const query: any = {};\n\n      if (appFilter) {\n        query.applicationids = _.flatten(_.map(filteredApps, 'applicationid'));\n      }\n      if (hostFilter) {\n        query.hostids = _.map(filteredHosts, 'hostid');\n      }\n      if (groupFilter) {\n        query.groupids = _.map(filteredGroups, 'groupid');\n      }\n\n      return query;\n    })\n    .then(query => this.zabbixAPI.getEventsHistory(query.groupids, query.hostids, query.applicationids, options))\n    .then(problems => {\n      const triggerids = problems?.map(problem => problem.objectid);\n      return Promise.all([Promise.resolve(problems), this.zabbixAPI.getTriggersByIds(triggerids)]);\n    })\n    .then(([problems, triggers]) => joinTriggersWithEvents(problems, triggers, { valueFromEvent }))\n    .then(triggers => this.filterTriggersByProxy(triggers, proxyFilter));\n    // .then(triggers => this.expandUserMacro.bind(this)(triggers, true));\n  }\n\n  filterTriggersByProxy(triggers, proxyFilter) {\n    return this.getFilteredProxies(proxyFilter)\n    .then(proxies => {\n      if (proxyFilter && proxyFilter !== '/.*/' && triggers) {\n        const proxy_ids = proxies.map(proxy => proxy.proxyid);\n        triggers = triggers.filter(trigger => {\n          for (let i = 0; i < trigger.hosts.length; i++) {\n            const host = trigger.hosts[i];\n            if (proxy_ids.includes(host.proxy_hostid)) {\n              return true;\n            }\n          }\n          return false;\n        });\n      }\n      return triggers;\n    });\n  }\n\n  getFilteredProxies(proxyFilter) {\n    return this.zabbixAPI.getProxies()\n    .then(proxies => {\n      proxies.forEach(proxy => proxy.name = proxy.host);\n      return findByFilter(proxies, proxyFilter);\n    });\n  }\n\n  getHistoryTS(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getHistoryDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleHistory(history, items));\n    }\n  }\n\n  getTrends(items, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    if (this.enableDirectDBConnection) {\n      return this.getTrendsDB(items, timeFrom, timeTo, options)\n      .then(history => this.dbConnector.handleGrafanaTSResponse(history, items));\n    } else {\n      const valueType = options.consolidateBy || options.valueType;\n      return this.zabbixAPI.getTrend(items, timeFrom, timeTo)\n      .then(history => responseHandler.handleTrends(history, items, valueType))\n      .then(responseHandler.sortTimeseries); // Sort trend data, issue #202\n    }\n  }\n\n  getHistoryText(items, timeRange, target) {\n    const [timeFrom, timeTo] = timeRange;\n    if (items.length) {\n      return this.zabbixAPI.getHistory(items, timeFrom, timeTo)\n      .then(history => {\n        if (target.resultFormat === 'table') {\n          return responseHandler.handleHistoryAsTable(history, items, target);\n        } else {\n          return responseHandler.handleText(history, items, target);\n        }\n      });\n    } else {\n      return Promise.resolve([]);\n    }\n  }\n\n  getSLA(itservices, timeRange, target, options) {\n    const itServiceIds = _.map(itservices, 'serviceid');\n    return this.zabbixAPI.getSLA(itServiceIds, timeRange, options)\n    .then(slaResponse => {\n      return _.map(itServiceIds, serviceid => {\n        const itservice = _.find(itservices, {'serviceid': serviceid});\n        return responseHandler.handleSLAResponse(itservice, target.slaProperty, slaResponse);\n      });\n    });\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Find group, host, app or item by given name.\n * @param  list list of groups, apps or other\n * @param  name visible name\n * @return      array with finded element or empty array\n */\nfunction findByName(list, name) {\n  const finded = _.find(list, {'name': name});\n  if (finded) {\n    return [finded];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Different hosts can contains applications and items with same name.\n * For this reason use _.filter, which return all elements instead _.find,\n * which return only first finded.\n * @param  {[type]} list list of elements\n * @param  {[type]} name app name\n * @return {[type]}      array with finded element or empty array\n */\nfunction filterByName(list, name) {\n  const finded = _.filter(list, {'name': name});\n  if (finded) {\n    return finded;\n  } else {\n    return [];\n  }\n}\n\nfunction filterByRegex(list, regex) {\n  const filterPattern = utils.buildRegex(regex);\n  return _.filter(list, (zbx_obj) => {\n    return filterPattern.test(zbx_obj.name);\n  });\n}\n\nfunction findByFilter(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return findByName(list, filter);\n  }\n}\n\nfunction filterByQuery(list, filter) {\n  if (utils.isRegex(filter)) {\n    return filterByRegex(list, filter);\n  } else {\n    return filterByName(list, filter);\n  }\n}\n\nfunction getHostIds(items) {\n  const hostIds = _.map(items, item => {\n    return _.map(item.hosts, 'hostid');\n  });\n  return _.uniq(_.flatten(hostIds));\n}\n","import _ from 'lodash';\nimport config from 'grafana/app/core/config';\nimport { contextSrv } from 'grafana/app/core/core';\nimport * as dateMath from 'grafana/app/core/utils/datemath';\nimport * as utils from './utils';\nimport * as migrations from './migrations';\nimport * as metricFunctions from './metricFunctions';\nimport * as c from './constants';\nimport { align, fillTrendsWithNulls } from './timeseries';\nimport dataProcessor from './dataProcessor';\nimport responseHandler from './responseHandler';\nimport problemsHandler from './problemsHandler';\nimport { Zabbix } from './zabbix/zabbix';\nimport { ZabbixAPIError } from './zabbix/connectors/zabbix_api/zabbixAPIConnector';\nimport { ZabbixMetricsQuery, ZabbixDSOptions, VariableQueryTypes, ShowProblemTypes, ProblemDTO } from './types';\nimport { getBackendSrv, getTemplateSrv } from '@grafana/runtime';\nimport { DataFrame, DataQueryRequest, DataQueryResponse, DataSourceApi, DataSourceInstanceSettings, FieldType, isDataFrame, LoadingState } from '@grafana/data';\n\nexport class ZabbixDatasource extends DataSourceApi<ZabbixMetricsQuery, ZabbixDSOptions> {\n  name: string;\n  basicAuth: any;\n  withCredentials: any;\n\n  trends: boolean;\n  trendsFrom: string;\n  trendsRange: string;\n  cacheTTL: any;\n  disableReadOnlyUsersAck: boolean;\n  disableDataAlignment: boolean;\n  enableDirectDBConnection: boolean;\n  dbConnectionDatasourceId: number;\n  dbConnectionDatasourceName: string;\n  dbConnectionRetentionPolicy: string;\n  enableDebugLog: boolean;\n  datasourceId: number;\n  zabbix: Zabbix;\n\n  replaceTemplateVars: (target: any, scopedVars?: any) => any;\n\n  /** @ngInject */\n  constructor(instanceSettings: DataSourceInstanceSettings<ZabbixDSOptions>, private templateSrv) {\n    super(instanceSettings);\n\n    this.templateSrv = templateSrv;\n    this.enableDebugLog = config.buildInfo.env === 'development';\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = _.partial(replaceTemplateVars, this.templateSrv);\n\n    // General data source settings\n    this.datasourceId     = instanceSettings.id;\n    this.name             = instanceSettings.name;\n    this.basicAuth        = instanceSettings.basicAuth;\n    this.withCredentials  = instanceSettings.withCredentials;\n\n    const jsonData = migrations.migrateDSConfig(instanceSettings.jsonData);\n\n    // Use trends instead history since specified time\n    this.trends           = jsonData.trends;\n    this.trendsFrom       = jsonData.trendsFrom || '7d';\n    this.trendsRange      = jsonData.trendsRange || '4d';\n\n    // Set cache update interval\n    const ttl = jsonData.cacheTTL || '1h';\n    this.cacheTTL = utils.parseInterval(ttl);\n\n    // Other options\n    this.disableReadOnlyUsersAck = jsonData.disableReadOnlyUsersAck;\n    this.disableDataAlignment = jsonData.disableDataAlignment;\n\n    // Direct DB Connection options\n    this.enableDirectDBConnection = jsonData.dbConnectionEnable || false;\n    this.dbConnectionDatasourceId = jsonData.dbConnectionDatasourceId;\n    this.dbConnectionDatasourceName = jsonData.dbConnectionDatasourceName;\n    this.dbConnectionRetentionPolicy = jsonData.dbConnectionRetentionPolicy;\n\n    const zabbixOptions = {\n      basicAuth: this.basicAuth,\n      withCredentials: this.withCredentials,\n      cacheTTL: this.cacheTTL,\n      enableDirectDBConnection: this.enableDirectDBConnection,\n      dbConnectionDatasourceId: this.dbConnectionDatasourceId,\n      dbConnectionDatasourceName: this.dbConnectionDatasourceName,\n      dbConnectionRetentionPolicy: this.dbConnectionRetentionPolicy,\n      datasourceId: this.datasourceId,\n    };\n\n    this.zabbix = new Zabbix(zabbixOptions);\n  }\n\n  ////////////////////////\n  // Datasource methods //\n  ////////////////////////\n\n  /**\n   * Query panel data. Calls for each panel in dashboard.\n   * @param  {Object} options   Contains time range, targets and other info.\n   * @return {Object} Grafana metrics object with timeseries data for each target.\n   */\n  query(options: DataQueryRequest<any>): Promise<DataQueryResponse> {\n    // Create request for each target\n    const promises = _.map(options.targets, t => {\n      // Don't request for hidden targets\n      if (t.hide) {\n        return [];\n      }\n\n      let timeFrom = Math.ceil(dateMath.parse(options.range.from) / 1000);\n      let timeTo = Math.ceil(dateMath.parse(options.range.to) / 1000);\n\n      // Add range variables\n      options.scopedVars = Object.assign({}, options.scopedVars, utils.getRangeScopedVars(options.range));\n\n      // Prevent changes of original object\n      let target = _.cloneDeep(t);\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n      this.replaceTargetVariables(target, options);\n\n      // Apply Time-related functions (timeShift(), etc)\n      const timeFunctions = bindFunctionDefs(target.functions, 'Time');\n      if (timeFunctions.length) {\n        const [time_from, time_to] = utils.sequence(timeFunctions)([timeFrom, timeTo]);\n        timeFrom = time_from;\n        timeTo = time_to;\n      }\n      const timeRange = [timeFrom, timeTo];\n\n      const useTrends = this.isUseTrends(timeRange);\n\n      // Metrics or Text query\n      if (!target.queryType || target.queryType === c.MODE_METRICS || target.queryType === c.MODE_TEXT) {\n        // Don't request undefined targets\n        if (!target.group || !target.host || !target.item) {\n          return [];\n        }\n\n        if (!target.queryType || target.queryType === c.MODE_METRICS) {\n          return this.queryNumericData(target, timeRange, useTrends, options);\n        } else if (target.queryType === c.MODE_TEXT) {\n          return this.queryTextData(target, timeRange);\n        } else {\n          return [];\n        }\n      } else if (target.queryType === c.MODE_ITEMID) {\n        // Item ID query\n        if (!target.itemids) {\n          return [];\n        }\n        return this.queryItemIdData(target, timeRange, useTrends, options);\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        // IT services query\n        return this.queryITServiceData(target, timeRange, options);\n      } else if (target.queryType === c.MODE_TRIGGERS) {\n        // Triggers query\n        return this.queryTriggersData(target, timeRange);\n      } else if (target.queryType === c.MODE_PROBLEMS) {\n        // Problems query\n        return this.queryProblems(target, timeRange, options);\n      } else {\n        return [];\n      }\n    });\n\n    // Data for panel (all targets)\n    return Promise.all(_.flatten(promises))\n      .then(_.flatten)\n      .then(data => {\n        if (data && data.length > 0 && isDataFrame(data[0]) && !utils.isProblemsDataFrame(data[0])) {\n          data = responseHandler.alignFrames(data);\n          if (responseHandler.isConvertibleToWide(data)) {\n            console.log('Converting response to the wide format');\n            data = responseHandler.convertToWide(data);\n          }\n        }\n        return data;\n      }).then(data => {\n        return {\n          data,\n          state: LoadingState.Done,\n          key: options.requestId,\n        };\n      });\n  }\n\n  doTsdbRequest(options) {\n    const tsdbRequestData: any = {\n      queries: options.targets.map(target => {\n        target.datasourceId = this.datasourceId;\n        target.queryType = 'zabbixAPI';\n        return target;\n      }),\n    };\n\n    if (options.range) {\n      tsdbRequestData.from = options.range.from.valueOf().toString();\n      tsdbRequestData.to = options.range.to.valueOf().toString();\n    }\n\n    return getBackendSrv().post('/api/tsdb/query', tsdbRequestData);\n  }\n\n  /**\n   * @returns {Promise<TSDBResponse>}\n   */\n  doTSDBConnectionTest() {\n    /**\n     * @type {{ queries: ZabbixConnectionTestQuery[] }}\n     */\n    const tsdbRequestData = {\n      queries: [\n        {\n          datasourceId: this.datasourceId,\n          queryType: 'connectionTest'\n        }\n      ]\n    };\n\n    return getBackendSrv().post('/api/tsdb/query', tsdbRequestData);\n  }\n\n  /**\n   * Query target data for Metrics\n   */\n  async queryNumericData(target, timeRange, useTrends, options): Promise<DataFrame[]> {\n    const getItemOptions = {\n      itemtype: 'num'\n    };\n\n    const items = await this.zabbix.getItemsFromTarget(target, getItemOptions);\n\n    const queryStart = new Date().getTime();\n    const result = await this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    const queryEnd = new Date().getTime();\n\n    if (this.enableDebugLog) {\n      console.log(`Datasource::Performance Query Time (${this.name}): ${queryEnd - queryStart}`);\n    }\n\n    const valueMappings = await this.zabbix.getValueMappings();\n\n    const dataFrames = result.map(s => responseHandler.seriesToDataFrame(s, target, valueMappings));\n    return dataFrames;\n  }\n\n  /**\n   * Query history for numeric items\n   */\n  queryNumericDataForItems(items, target: ZabbixMetricsQuery, timeRange, useTrends, options) {\n    let getHistoryPromise;\n    options.valueType = this.getTrendValueType(target);\n    options.consolidateBy = getConsolidateBy(target) || options.valueType;\n    const disableDataAlignment = this.disableDataAlignment || target.options?.disableDataAlignment;\n\n    if (useTrends) {\n      getHistoryPromise = this.zabbix.getTrends(items, timeRange, options)\n      .then(timeseries => {\n        return !disableDataAlignment ? this.fillTrendTimeSeriesWithNulls(timeseries) : timeseries;\n      });\n    } else {\n      getHistoryPromise = this.zabbix.getHistoryTS(items, timeRange, options)\n      .then(timeseries => {\n        return !disableDataAlignment ? this.alignTimeSeriesData(timeseries) : timeseries;\n      });\n    }\n\n    return getHistoryPromise\n    .then(timeseries => this.applyDataProcessingFunctions(timeseries, target))\n    .then(timeseries => downsampleSeries(timeseries, options));\n  }\n\n  getTrendValueType(target) {\n    // Find trendValue() function and get specified trend value\n    const trendFunctions = _.map(metricFunctions.getCategories()['Trends'], 'name');\n    const trendValueFunc = _.find(target.functions, func => {\n      return _.includes(trendFunctions, func.def.name);\n    });\n    return trendValueFunc ? trendValueFunc.params[0] : \"avg\";\n  }\n\n  alignTimeSeriesData(timeseries: any[]) {\n    for (const ts of timeseries) {\n      const interval = utils.parseItemInterval(ts.scopedVars['__zbx_item_interval']?.value);\n      ts.datapoints = align(ts.datapoints, interval);\n    }\n    return timeseries;\n  }\n\n  fillTrendTimeSeriesWithNulls(timeseries: any[]) {\n    for (const ts of timeseries) {\n      ts.datapoints = fillTrendsWithNulls(ts.datapoints);\n    }\n    return timeseries;\n  }\n\n  applyDataProcessingFunctions(timeseries_data, target) {\n    const transformFunctions   = bindFunctionDefs(target.functions, 'Transform');\n    const aggregationFunctions = bindFunctionDefs(target.functions, 'Aggregate');\n    const filterFunctions      = bindFunctionDefs(target.functions, 'Filter');\n    const aliasFunctions       = bindFunctionDefs(target.functions, 'Alias');\n\n    // Apply transformation functions\n    timeseries_data = _.cloneDeep(_.map(timeseries_data, timeseries => {\n      timeseries.datapoints = utils.sequence(transformFunctions)(timeseries.datapoints);\n      return timeseries;\n    }));\n\n    // Apply filter functions\n    if (filterFunctions.length) {\n      timeseries_data = utils.sequence(filterFunctions)(timeseries_data);\n    }\n\n    // Apply aggregations\n    if (aggregationFunctions.length) {\n      let dp = _.map(timeseries_data, 'datapoints');\n      dp = utils.sequence(aggregationFunctions)(dp);\n\n      const aggFuncNames = _.map(metricFunctions.getCategories()['Aggregate'], 'name');\n      const lastAgg = _.findLast(target.functions, func => {\n        return _.includes(aggFuncNames, func.def.name);\n      });\n\n      timeseries_data = [{\n        target: lastAgg.text,\n        datapoints: dp\n      }];\n    }\n\n    // Apply alias functions\n    _.forEach(timeseries_data, utils.sequence(aliasFunctions).bind(this));\n\n    // Apply Time-related functions (timeShift(), etc)\n    // Find timeShift() function and get specified trend value\n    this.applyTimeShiftFunction(timeseries_data, target);\n\n    return timeseries_data;\n  }\n\n  applyTimeShiftFunction(timeseries_data, target) {\n    // Find timeShift() function and get specified interval\n    const timeShiftFunc = _.find(target.functions, (func) => {\n      return func.def.name === 'timeShift';\n    });\n    if (timeShiftFunc) {\n      const shift = timeShiftFunc.params[0];\n      _.forEach(timeseries_data, (series) => {\n        series.datapoints = dataProcessor.unShiftTimeSeries(shift, series.datapoints);\n      });\n    }\n  }\n\n  /**\n   * Query target data for Text\n   */\n  queryTextData(target, timeRange) {\n    const options = {\n      itemtype: 'text'\n    };\n    return this.zabbix.getItemsFromTarget(target, options)\n    .then(items => {\n      return this.zabbix.getHistoryText(items, timeRange, target);\n    })\n    .then(result => {\n      if (target.resultFormat !== 'table') {\n        return result.map(s => responseHandler.seriesToDataFrame(s, target, [], FieldType.string));\n      }\n      return result;\n    });\n  }\n\n  /**\n   * Query target data for Item ID\n   */\n  queryItemIdData(target, timeRange, useTrends, options) {\n    let itemids = target.itemids;\n    itemids = this.templateSrv.replace(itemids, options.scopedVars, zabbixItemIdsTemplateFormat);\n    itemids = _.map(itemids.split(','), itemid => itemid.trim());\n\n    if (!itemids) {\n      return [];\n    }\n\n    return this.zabbix.getItemsByIDs(itemids)\n    .then(items => {\n      return this.queryNumericDataForItems(items, target, timeRange, useTrends, options);\n    })\n    .then(result => {\n      return result.map(s => responseHandler.seriesToDataFrame(s, target));\n    });\n  }\n\n  /**\n   * Query target data for IT Services\n   */\n  queryITServiceData(target, timeRange, options) {\n    // Don't show undefined and hidden targets\n    if (target.hide || (!target.itservice && !target.itServiceFilter) || !target.slaProperty) {\n      return [];\n    }\n\n    let itServiceFilter;\n    options.isOldVersion = target.itservice && !target.itServiceFilter;\n\n    if (options.isOldVersion) {\n      // Backward compatibility\n      itServiceFilter = '/.*/';\n    } else {\n      itServiceFilter = this.replaceTemplateVars(target.itServiceFilter, options.scopedVars);\n    }\n\n    options.slaInterval = target.slaInterval;\n\n    return this.zabbix.getITServices(itServiceFilter)\n    .then(itservices => {\n      if (options.isOldVersion) {\n        itservices = _.filter(itservices, {'serviceid': target.itservice?.serviceid});\n      }\n      return this.zabbix.getSLA(itservices, timeRange, target, options);})\n    .then(itservicesdp => this.applyDataProcessingFunctions(itservicesdp, target))\n    .then(result => {\n      const dataFrames = result.map(s => responseHandler.seriesToDataFrame(s, target));\n      return dataFrames;\n    });\n  }\n\n  queryTriggersData(target, timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    return this.zabbix.getHostsFromTarget(target)\n    .then(results => {\n      const [hosts, apps] = results;\n      if (hosts.length) {\n        const hostids = _.map(hosts, 'hostid');\n        const appids = _.map(apps, 'applicationid');\n        const options = {\n          minSeverity: target.triggers.minSeverity,\n          acknowledged: target.triggers.acknowledged,\n          count: target.triggers.count,\n          timeFrom: timeFrom,\n          timeTo: timeTo\n        };\n        const groupFilter = target.group.filter;\n        return Promise.all([\n          this.zabbix.getHostAlerts(hostids, appids, options),\n          this.zabbix.getGroups(groupFilter)\n        ])\n        .then(([triggers, groups]) => {\n          return responseHandler.handleTriggersResponse(triggers, groups, timeRange);\n        });\n      } else {\n        return Promise.resolve([]);\n      }\n    });\n  }\n\n  queryProblems(target: ZabbixMetricsQuery, timeRange, options) {\n    const [timeFrom, timeTo] = timeRange;\n    const userIsEditor = contextSrv.isEditor || contextSrv.isGrafanaAdmin;\n\n    let proxies;\n    let showAckButton = true;\n\n    const showProblems = target.showProblems || ShowProblemTypes.Problems;\n    const showProxy = target.options.hostProxy;\n\n    const getProxiesPromise = showProxy ? this.zabbix.getProxies() : () => [];\n    showAckButton = !this.disableReadOnlyUsersAck || userIsEditor;\n\n    // Replace template variables\n    const groupFilter = this.replaceTemplateVars(target.group?.filter, options.scopedVars);\n    const hostFilter = this.replaceTemplateVars(target.host?.filter, options.scopedVars);\n    const appFilter = this.replaceTemplateVars(target.application?.filter, options.scopedVars);\n    const proxyFilter = this.replaceTemplateVars(target.proxy?.filter, options.scopedVars);\n\n    const triggerFilter = this.replaceTemplateVars(target.trigger?.filter, options.scopedVars);\n    const tagsFilter = this.replaceTemplateVars(target.tags?.filter, options.scopedVars);\n\n    const replacedTarget = {\n      ...target,\n      trigger: { filter: triggerFilter },\n      tags: { filter: tagsFilter },\n    };\n\n    // replaceTemplateVars() builds regex-like string, so we should trim it.\n    const tagsFilterStr = tagsFilter.replace('/^', '').replace('$/', '');\n    const tags = utils.parseTags(tagsFilterStr);\n    tags.forEach(tag => {\n      // Zabbix uses {\"tag\": \"<tag>\", \"value\": \"<value>\", \"operator\": \"<operator>\"} format, where 1 means Equal\n      tag.operator = 1;\n    });\n\n    const problemsOptions: any = {\n      recent: showProblems === ShowProblemTypes.Recent,\n      minSeverity: target.options?.minSeverity,\n      limit: target.options?.limit,\n    };\n\n    if (tags && tags.length) {\n      problemsOptions.tags = tags;\n    }\n\n    if (target.options?.acknowledged === 0 || target.options?.acknowledged === 1) {\n      problemsOptions.acknowledged = target.options?.acknowledged ? true : false;\n    }\n\n    if (target.options?.minSeverity) {\n      let severities = [0, 1, 2, 3, 4, 5].filter(v => v >= target.options?.minSeverity);\n      if (target.options?.severities) {\n        severities = severities.filter(v => target.options?.severities.includes(v));\n      }\n      problemsOptions.severities = severities;\n    }\n\n    let getProblemsPromise: Promise<ProblemDTO[]>;\n    if (showProblems === ShowProblemTypes.History || target.options?.useTimeRange) {\n      problemsOptions.timeFrom = timeFrom;\n      problemsOptions.timeTo = timeTo;\n      getProblemsPromise = this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions);\n    } else {\n      getProblemsPromise = this.zabbix.getProblems(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions);\n    }\n\n    const problemsPromises = Promise.all([\n      getProblemsPromise,\n      getProxiesPromise\n    ])\n    .then(([problems, sourceProxies]) => {\n      proxies = _.keyBy(sourceProxies, 'proxyid');\n      return problems;\n    })\n    .then(problems => problemsHandler.setMaintenanceStatus(problems))\n    .then(problems => problemsHandler.setAckButtonStatus(problems, showAckButton))\n    .then(problems => problemsHandler.filterTriggersPre(problems, replacedTarget))\n    .then(problems => problemsHandler.sortProblems(problems, target))\n    .then(problems => problemsHandler.addTriggerDataSource(problems, target))\n    .then(problems => problemsHandler.addTriggerHostProxy(problems, proxies));\n\n    return problemsPromises.then(problems => {\n      const problemsDataFrame = problemsHandler.toDataFrame(problems);\n      return problemsDataFrame;\n    });\n  }\n\n  /**\n   * Test connection to Zabbix API and external history DB.\n   */\n  async testDatasource() {\n    try {\n      const { zabbixVersion, dbConnectorStatus } = await this.zabbix.testDataSource();\n      let message = `Zabbix API version: ${zabbixVersion}`;\n      if (dbConnectorStatus) {\n        message += `, DB connector type: ${dbConnectorStatus.dsType}`;\n      }\n      return {\n        status: \"success\",\n        title: \"Success\",\n        message: message\n      };\n    } catch (error) {\n      if (error instanceof ZabbixAPIError) {\n        return {\n          status: \"error\",\n          title: error.message,\n          message: error.message\n        };\n      } else if (error.data && error.data.message) {\n        return {\n          status: \"error\",\n          title: \"Zabbix Client Error\",\n          message: error.data.message\n        };\n      } else if (typeof (error) === 'string') {\n        return {\n          status: \"error\",\n          title: \"Unknown Error\",\n          message: error\n        };\n      } else {\n        console.log(error);\n        return {\n          status: \"error\",\n          title: \"Connection failed\",\n          message: \"Could not connect to given url\"\n        };\n      }\n    }\n  }\n\n  ////////////////\n  // Templating //\n  ////////////////\n\n  /**\n   * Find metrics from templated request.\n   *\n   * @param  {string} query Query from Templating\n   * @return {string}       Metric name - group, host, app or item or list\n   *                        of metrics in \"{metric1,metcic2,...,metricN}\" format.\n   */\n  metricFindQuery(query, options) {\n    let resultPromise;\n    let queryModel = _.cloneDeep(query);\n\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    if (typeof query === 'string') {\n      // Backward compatibility\n      queryModel = utils.parseLegacyVariableQuery(query);\n    }\n\n    for (const prop of ['group', 'host', 'application', 'item']) {\n      queryModel[prop] = this.replaceTemplateVars(queryModel[prop], {});\n    }\n\n    const { group, host, application, item } = queryModel;\n\n    switch (queryModel.queryType) {\n      case VariableQueryTypes.Group:\n        resultPromise = this.zabbix.getGroups(queryModel.group);\n        break;\n      case VariableQueryTypes.Host:\n        resultPromise = this.zabbix.getHosts(queryModel.group, queryModel.host);\n        break;\n      case VariableQueryTypes.Application:\n        resultPromise = this.zabbix.getApps(queryModel.group, queryModel.host, queryModel.application);\n        break;\n      case VariableQueryTypes.Item:\n        resultPromise = this.zabbix.getItems(queryModel.group, queryModel.host, queryModel.application, queryModel.item);\n        break;\n      case VariableQueryTypes.ItemValues:\n        const range = options?.range;\n        resultPromise = this.zabbix.getItemValues(group, host, application, item, { range });\n        break;\n      default:\n        resultPromise = Promise.resolve([]);\n        break;\n    }\n\n    return resultPromise.then(metrics => {\n      return _.map(metrics, formatMetric);\n    });\n  }\n\n  targetContainsTemplate(target: ZabbixMetricsQuery): boolean {\n    const templateSrv = getTemplateSrv() as any;\n    return (\n      templateSrv.variableExists(target.group?.filter) ||\n      templateSrv.variableExists(target.host?.filter) ||\n      templateSrv.variableExists(target.application?.filter) ||\n      templateSrv.variableExists(target.item?.filter) ||\n      templateSrv.variableExists(target.proxy?.filter) ||\n      templateSrv.variableExists(target.trigger?.filter) ||\n      templateSrv.variableExists(target.textFilter) ||\n      templateSrv.variableExists(target.itServiceFilter)\n    );\n  }\n\n  /////////////////\n  // Annotations //\n  /////////////////\n\n  annotationQuery(options) {\n    const timeRange = options.range || options.rangeRaw;\n    const timeFrom = Math.ceil(dateMath.parse(timeRange.from) / 1000);\n    const timeTo = Math.ceil(dateMath.parse(timeRange.to) / 1000);\n    const annotation = options.annotation;\n\n    // Show all triggers\n    const problemsOptions: any = {\n      value: annotation.showOkEvents ? ['0', '1'] : '1',\n      valueFromEvent: true,\n      timeFrom,\n      timeTo,\n    };\n\n    if (annotation.minseverity) {\n      const severities = [0, 1, 2, 3, 4, 5].filter(v => v >= Number(annotation.minseverity));\n      problemsOptions.severities = severities;\n    }\n\n    const groupFilter = this.replaceTemplateVars(annotation.group, {});\n    const hostFilter = this.replaceTemplateVars(annotation.host, {});\n    const appFilter = this.replaceTemplateVars(annotation.application, {});\n    const proxyFilter = undefined;\n\n    return this.zabbix.getProblemsHistory(groupFilter, hostFilter, appFilter, proxyFilter, problemsOptions)\n    .then(problems => {\n      // Filter triggers by description\n      const problemName = this.replaceTemplateVars(annotation.trigger, {});\n      if (utils.isRegex(problemName)) {\n        problems = _.filter(problems, p => {\n          return utils.buildRegex(problemName).test(p.description);\n        });\n      } else if (problemName) {\n        problems = _.filter(problems, p => {\n          return p.description === problemName;\n        });\n      }\n\n      // Hide acknowledged events if option enabled\n      if (annotation.hideAcknowledged) {\n        problems = _.filter(problems, p => {\n          return !p.acknowledges?.length;\n        });\n      }\n\n      return _.map(problems, p => {\n        const formattedAcknowledges = utils.formatAcknowledges(p.acknowledges);\n\n        let annotationTags: string[] = [];\n        if (annotation.showHostname) {\n          annotationTags = _.map(p.hosts, 'name');\n        }\n\n        return {\n          title: p.value === '1' ? 'Problem' : 'OK',\n          time: p.timestamp * 1000,\n          annotation: annotation,\n          text: p.name + formattedAcknowledges,\n          tags: annotationTags,\n        };\n      });\n    });\n  }\n\n  // Replace template variables\n  replaceTargetVariables(target, options) {\n    const parts = ['group', 'host', 'application', 'item'];\n    _.forEach(parts, p => {\n      if (target[p] && target[p].filter) {\n        target[p].filter = this.replaceTemplateVars(target[p].filter, options.scopedVars);\n      }\n    });\n\n    if (target.textFilter) {\n      target.textFilter = this.replaceTemplateVars(target.textFilter, options.scopedVars);\n    }\n\n    _.forEach(target.functions, func => {\n      func.params = _.map(func.params, param => {\n        if (typeof param === 'number') {\n          return +this.templateSrv.replace(param.toString(), options.scopedVars);\n        } else {\n          return this.templateSrv.replace(param, options.scopedVars);\n        }\n      });\n    });\n  }\n\n  isUseTrends(timeRange) {\n    const [timeFrom, timeTo] = timeRange;\n    const useTrendsFrom = Math.ceil(dateMath.parse('now-' + this.trendsFrom) / 1000);\n    const useTrendsRange = Math.ceil(utils.parseInterval(this.trendsRange) / 1000);\n    const useTrends = this.trends && (\n      (timeFrom < useTrendsFrom) ||\n      (timeTo - timeFrom > useTrendsRange)\n    );\n    return useTrends;\n  }\n}\n\nfunction bindFunctionDefs(functionDefs, category) {\n  const aggregationFunctions = _.map(metricFunctions.getCategories()[category], 'name');\n  const aggFuncDefs = _.filter(functionDefs, func => {\n    return _.includes(aggregationFunctions, func.def.name);\n  });\n\n  return _.map(aggFuncDefs, func => {\n    const funcInstance = metricFunctions.createFuncInstance(func.def, func.params);\n    return funcInstance.bindFunction(dataProcessor.metricFunctions);\n  });\n}\n\nfunction getConsolidateBy(target) {\n  let consolidateBy;\n  const funcDef = _.find(target.functions, func => {\n    return func.def.name === 'consolidateBy';\n  });\n  if (funcDef && funcDef.params && funcDef.params.length) {\n    consolidateBy = funcDef.params[0];\n  }\n  return consolidateBy;\n}\n\nfunction downsampleSeries(timeseries_data, options) {\n  const defaultAgg = dataProcessor.aggregationFunctions['avg'];\n  const consolidateByFunc = dataProcessor.aggregationFunctions[options.consolidateBy] || defaultAgg;\n  return _.map(timeseries_data, timeseries => {\n    if (timeseries.datapoints.length > options.maxDataPoints) {\n      timeseries.datapoints = dataProcessor\n        .groupBy(options.interval, consolidateByFunc, timeseries.datapoints);\n    }\n    return timeseries;\n  });\n}\n\nfunction formatMetric(metricObj) {\n  return {\n    text: metricObj.name,\n    expandable: false\n  };\n}\n\n/**\n * Custom formatter for template variables.\n * Default Grafana \"regex\" formatter returns\n * value1|value2\n * This formatter returns\n * (value1|value2)\n * This format needed for using in complex regex with\n * template variables, for example\n * /CPU $cpu_item.*time/ where $cpu_item is system,user,iowait\n */\nexport function zabbixTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return utils.escapeRegex(value);\n  }\n\n  const escapedValues = _.map(value, utils.escapeRegex);\n  return '(' + escapedValues.join('|') + ')';\n}\n\nfunction zabbixItemIdsTemplateFormat(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return value.join(',');\n}\n\n/**\n * If template variables are used in request, replace it using regex format\n * and wrap with '/' for proper multi-value work. Example:\n * $variable selected as a, b, c\n * We use filter $variable\n * $variable    -> a|b|c    -> /a|b|c/\n * /$variable/  -> /a|b|c/  -> /a|b|c/\n */\nfunction replaceTemplateVars(templateSrv, target, scopedVars) {\n  let replacedTarget = templateSrv.replace(target, scopedVars, zabbixTemplateFormat);\n  if (target && target !== replacedTarget && !utils.isRegex(replacedTarget)) {\n    replacedTarget = '/^' + replacedTarget + '$/';\n  }\n  return replacedTarget;\n}\n\nfunction filterEnabledTargets(targets) {\n  return _.filter(targets, target => {\n    return !(target.hide || !target.group || !target.host || !target.item);\n  });\n}\n","import React, { FC } from 'react';\nimport { css, cx } from 'emotion';\nimport { EventsWithValidation, ValidationEvents, useTheme } from '@grafana/ui';\nimport { GrafanaTheme } from '@grafana/data';\nimport { isRegex, variableRegex } from '../utils';\n\nimport * as grafanaUi from '@grafana/ui';\nconst Input = (grafanaUi as any).LegacyForms?.Input || (grafanaUi as any).Input;\n\nconst variablePattern = RegExp(`^${variableRegex.source}`);\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  inputRegex: css`\n    color: ${theme.palette.orange}\n  `,\n  inputVariable: css`\n    color: ${theme.colors.textBlue}\n  `,\n});\n\nconst zabbixInputValidationEvents: ValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    {\n      rule: value => {\n        if (!value) {\n          return true;\n        }\n        if (value.length > 1 && value[0] === '/') {\n          if (value[value.length - 1] !== '/') {\n            return false;\n          }\n        }\n        return true;\n      },\n      errorMessage: 'Not a valid regex',\n    },\n    {\n      rule: value => {\n        if (value === '*') {\n          return false;\n        }\n        return true;\n      },\n      errorMessage: 'Wildcards not supported. Use /.*/ instead',\n    },\n  ],\n};\n\nexport const ZabbixInput: FC<any> = ({ value, ref, validationEvents, ...restProps }) => {\n  const theme = useTheme();\n  const styles = getStyles(theme);\n\n  let inputClass = styles.inputRegex;\n  if (variablePattern.test(value as string)) {\n    inputClass = styles.inputVariable;\n  } else if (isRegex(value)) {\n    inputClass = styles.inputRegex;\n  }\n\n  return (\n    <Input\n      className={inputClass}\n      value={value}\n      validationEvents={zabbixInputValidationEvents}\n      {...restProps}\n    />\n  );\n};\n","import { QueryCtrl } from 'grafana/app/plugins/sdk';\nimport _ from 'lodash';\nimport * as c from './constants';\nimport * as utils from './utils';\nimport * as metricFunctions from './metricFunctions';\nimport * as migrations from './migrations';\nimport { ShowProblemTypes, ZabbixMetricsQuery } from './types';\nimport { CURRENT_SCHEMA_VERSION } from '../panel-triggers/migrations';\nimport { getTemplateSrv, TemplateSrv } from '@grafana/runtime';\n\n\nfunction getTargetDefaults() {\n  return {\n    queryType: c.MODE_METRICS,\n    group: { 'filter': \"\" },\n    host: { 'filter': \"\" },\n    application: { 'filter': \"\" },\n    item: { 'filter': \"\" },\n    functions: [],\n    triggers: {\n      'count': true,\n      'minSeverity': 3,\n      'acknowledged': 2\n    },\n    trigger: {filter: \"\"},\n    tags: {filter: \"\"},\n    proxy: {filter: \"\"},\n    options: {\n      showDisabledItems: false,\n      skipEmptyValues: false,\n      disableDataAlignment: false,\n      useZabbixValueMapping: false,\n    },\n    table: {\n      'skipEmptyValues': false\n    },\n  };\n}\n\nfunction getSLATargetDefaults() {\n  return {\n    slaProperty: { name: \"SLA\", property: \"sla\" },\n    slaInterval: 'none',\n  };\n}\n\nfunction getProblemsTargetDefaults() {\n  return {\n    showProblems: ShowProblemTypes.Problems,\n    options: {\n      minSeverity: 0,\n      sortProblems: 'default',\n      acknowledged: 2,\n      hostsInMaintenance: false,\n      hostProxy: false,\n      limit: c.DEFAULT_ZABBIX_PROBLEMS_LIMIT,\n    },\n  };\n}\n\nfunction getSeverityOptions() {\n  return c.TRIGGER_SEVERITY;\n}\n\nfunction mapSeverityOptionsFromPanel(severityOptions: any[]) {\n  if (!severityOptions) {\n    return [0, 1, 2, 3, 4, 5];\n  }\n\n  const severities = [];\n  for (const sevOption of severityOptions) {\n    if (sevOption.show) {\n      severities.push(sevOption.priority);\n    }\n  }\n  return severities;\n}\n\nexport class ZabbixQueryController extends QueryCtrl {\n  static templateUrl: string;\n\n  zabbix: any;\n  replaceTemplateVars: any;\n  templateSrv: TemplateSrv;\n  editorModes: Array<{ value: string; text: string; queryType: number; }>;\n  slaPropertyList: Array<{ name: string; property: string; }>;\n  slaIntervals: Array<{ text: string; value: string; }>;\n  ackFilters: Array<{ text: string; value: number; }>;\n  problemAckFilters: string[];\n  sortByFields: Array<{ text: string; value: string; }>;\n  showEventsFields: Array<{ text: string; value: number[]; } | { text: string; value: number; }>;\n  showProblemsOptions: Array<{ text: string; value: string; }>;\n  resultFormats: Array<{ text: string; value: string; }>;\n  severityOptions: Array<{ val: number; text: string; }>;\n  getGroupNames: (...args: any[]) => any;\n  getHostNames: (...args: any[]) => any;\n  getApplicationNames: (...args: any[]) => any;\n  getItemNames: (...args: any[]) => any;\n  getITServices: (...args: any[]) => any;\n  getProxyNames: (...args: any[]) => any;\n  getVariables: (...args: any[]) => any;\n  init: () => void;\n  queryOptionsText: string;\n  metric: any;\n  showQueryOptions: boolean;\n  oldTarget: any;\n\n  /** @ngInject */\n  constructor($scope, $injector, $rootScope) {\n    super($scope, $injector);\n    this.zabbix = this.datasource.zabbix;\n\n    // Use custom format for template variables\n    this.replaceTemplateVars = this.datasource.replaceTemplateVars;\n    this.templateSrv = getTemplateSrv();\n\n    this.editorModes = [\n      {value: 'num',       text: 'Metrics',     queryType: c.MODE_METRICS},\n      {value: 'text',      text: 'Text',        queryType: c.MODE_TEXT},\n      {value: 'itservice', text: 'IT Services', queryType: c.MODE_ITSERVICE},\n      {value: 'itemid',    text: 'Item ID',     queryType: c.MODE_ITEMID},\n      {value: 'triggers',  text: 'Triggers',    queryType: c.MODE_TRIGGERS},\n      {value: 'problems',  text: 'Problems',    queryType: c.MODE_PROBLEMS},\n    ];\n\n    this.$scope.editorMode = {\n      METRICS: c.MODE_METRICS,\n      TEXT: c.MODE_TEXT,\n      ITSERVICE: c.MODE_ITSERVICE,\n      ITEMID: c.MODE_ITEMID,\n      TRIGGERS: c.MODE_TRIGGERS,\n      PROBLEMS: c.MODE_PROBLEMS,\n    };\n\n    this.slaPropertyList = [\n      {name: \"Status\", property: \"status\"},\n      {name: \"SLA\", property: \"sla\"},\n      {name: \"OK time\", property: \"okTime\"},\n      {name: \"Problem time\", property: \"problemTime\"},\n      {name: \"Down time\", property: \"downtimeTime\"}\n    ];\n\n    this.slaIntervals = [\n      { text: 'No interval', value: 'none' },\n      { text: 'Auto', value: 'auto' },\n      { text: '1 hour', value: '1h' },\n      { text: '12 hours', value: '12h' },\n      { text: '24 hours', value: '1d' },\n      { text: '1 week', value: '1w' },\n      { text: '1 month', value: '1M' },\n    ];\n\n    this.ackFilters = [\n      {text: 'all triggers', value: 2},\n      {text: 'unacknowledged', value: 0},\n      {text: 'acknowledged', value: 1},\n    ];\n\n    this.problemAckFilters = [\n      'all triggers',\n      'unacknowledged',\n      'acknowledged'\n    ];\n\n    this.sortByFields = [\n      { text: 'Default', value: 'default' },\n      { text: 'Last change', value: 'lastchange' },\n      { text: 'Severity',    value: 'severity' },\n    ];\n\n    this.showEventsFields = [\n      { text: 'All',      value: [0,1] },\n      { text: 'OK',       value: [0] },\n      { text: 'Problems', value: 1 }\n    ];\n\n    this.showProblemsOptions = [\n      { text: 'Problems', value: 'problems' },\n      { text: 'Recent problems', value: 'recent' },\n      { text: 'History', value: 'history' },\n    ];\n\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n\n    this.severityOptions = getSeverityOptions();\n\n    // Map functions for bs-typeahead\n    this.getGroupNames = _.bind(this.getMetricNames, this, 'groupList');\n    this.getHostNames = _.bind(this.getMetricNames, this, 'hostList', true);\n    this.getApplicationNames = _.bind(this.getMetricNames, this, 'appList');\n    this.getItemNames = _.bind(this.getMetricNames, this, 'itemList');\n    this.getITServices = _.bind(this.getMetricNames, this, 'itServiceList');\n    this.getProxyNames = _.bind(this.getMetricNames, this, 'proxyList');\n    this.getVariables = _.bind(this.getTemplateVariables, this);\n\n    // Update metric suggestion when template variable was changed\n    $rootScope.$on('template-variable-value-updated', () => this.onVariableChange());\n\n    // Update metrics when item selected from dropdown\n    $scope.$on('typeahead-updated', () => {\n      this.onTargetBlur();\n    });\n\n    this.init = function() {\n      let target = this.target;\n\n      // Migrate old targets\n      target = migrations.migrate(target);\n\n      const scopeDefaults = {\n        metric: {},\n        oldTarget: _.cloneDeep(this.target),\n        queryOptionsText: this.renderQueryOptionsText()\n      };\n      _.defaults(this, scopeDefaults);\n\n      // Load default values\n      const targetDefaults = getTargetDefaults();\n      _.defaultsDeep(target, targetDefaults);\n\n      if (this.panel.type === c.ZABBIX_PROBLEMS_PANEL_ID) {\n        target.queryType = c.MODE_PROBLEMS;\n        target.options.severities = mapSeverityOptionsFromPanel(this.panel.triggerSeverity);\n      }\n\n      // Create function instances from saved JSON\n      target.functions = _.map(target.functions, func => {\n        return metricFunctions.createFuncInstance(func.def, func.params);\n      });\n\n      if (target.queryType === c.MODE_ITSERVICE) {\n        _.defaultsDeep(target, getSLATargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_PROBLEMS) {\n        _.defaultsDeep(target, getProblemsTargetDefaults());\n      }\n\n      if (target.queryType === c.MODE_METRICS ||\n          target.queryType === c.MODE_TEXT ||\n          target.queryType === c.MODE_TRIGGERS ||\n          target.queryType === c.MODE_PROBLEMS) {\n        this.initFilters();\n      } else if (target.queryType === c.MODE_ITSERVICE) {\n        this.suggestITServices();\n      }\n    };\n\n    // Update panel schema version to prevent unnecessary migrations\n    if (this.panel.type === c.ZABBIX_PROBLEMS_PANEL_ID) {\n      this.panel.schemaVersion = CURRENT_SCHEMA_VERSION;\n    }\n\n    this.init();\n    this.queryOptionsText = this.renderQueryOptionsText();\n  }\n\n  initFilters() {\n    const mode = _.find(this.editorModes, {'queryType': this.target.queryType});\n    const itemtype = mode ? mode.value : null;\n    const promises = [\n      this.suggestGroups(),\n      this.suggestHosts(),\n      this.suggestApps(),\n    ];\n\n    if (this.target.queryType === c.MODE_METRICS || this.target.queryType === c.MODE_TEXT) {\n      promises.push(this.suggestItems(itemtype));\n    }\n\n    if (this.target.queryType === c.MODE_PROBLEMS) {\n      promises.push(this.suggestProxies());\n    }\n\n    return Promise.all(promises);\n  }\n\n  // Get list of metric names for bs-typeahead directive\n  getMetricNames(metricList, addAllValue) {\n    const metrics = _.uniq(_.map(this.metric[metricList], 'name'));\n\n    // Add template variables\n    _.forEach(this.templateSrv.getVariables(), variable => {\n      metrics.unshift('$' + variable.name);\n    });\n\n    if (addAllValue) {\n      metrics.unshift('/.*/');\n    }\n\n    return metrics;\n  }\n\n  getTemplateVariables() {\n    return _.map(this.templateSrv.getVariables(), variable => {\n      return '$' + variable.name;\n    });\n  }\n\n  suggestGroups() {\n    return this.zabbix.getAllGroups()\n    .then(groups => {\n      this.metric.groupList = groups;\n      return groups;\n    });\n  }\n\n  suggestHosts() {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    return this.zabbix.getAllHosts(groupFilter)\n    .then(hosts => {\n      this.metric.hostList = hosts;\n      return hosts;\n    });\n  }\n\n  suggestApps() {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    const hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    return this.zabbix.getAllApps(groupFilter, hostFilter)\n    .then(apps => {\n      this.metric.appList = apps;\n      return apps;\n    });\n  }\n\n  suggestItems(itemtype = 'num') {\n    const groupFilter = this.replaceTemplateVars(this.target.group.filter);\n    const hostFilter = this.replaceTemplateVars(this.target.host.filter);\n    const appFilter = this.replaceTemplateVars(this.target.application.filter);\n    const options = {\n      itemtype: itemtype,\n      showDisabledItems: this.target.options.showDisabledItems\n    };\n\n    return this.zabbix\n    .getAllItems(groupFilter, hostFilter, appFilter, options)\n    .then(items => {\n      this.metric.itemList = items;\n      return items;\n    });\n  }\n\n  suggestITServices() {\n    return this.zabbix.getITService()\n    .then(itservices => {\n      this.metric.itServiceList = itservices;\n      return itservices;\n    });\n  }\n\n  suggestProxies() {\n    return this.zabbix.getProxies()\n    .then(response => {\n      const proxies = _.map(response, 'host');\n      this.metric.proxyList = proxies;\n      return proxies;\n    });\n  }\n\n  isRegex(str) {\n    return utils.isRegex(str);\n  }\n\n  isVariable(str) {\n    return utils.isTemplateVariable(str, this.templateSrv.getVariables());\n  }\n\n  onTargetBlur() {\n    const newTarget = _.cloneDeep(this.target);\n    if (!_.isEqual(this.oldTarget, this.target)) {\n      this.oldTarget = newTarget;\n      this.targetChanged();\n    }\n  }\n\n  onVariableChange() {\n    if (this.isContainsVariables()) {\n      this.targetChanged();\n    }\n  }\n\n  /**\n   * Check query for template variables\n   */\n  isContainsVariables() {\n    return _.some(['group', 'host', 'application'], field => {\n      if (this.target[field] && this.target[field].filter) {\n        return utils.isTemplateVariable(this.target[field].filter, this.templateSrv.getVariables());\n      } else {\n        return false;\n      }\n    });\n  }\n\n  parseTarget() {\n    // Parse target\n  }\n\n  // Validate target and set validation info\n  validateTarget() {\n    // validate\n  }\n\n  targetChanged() {\n    this.initFilters();\n    this.parseTarget();\n    this.refresh();\n  }\n\n  addFunction(funcDef) {\n    const newFunc = metricFunctions.createFuncInstance(funcDef);\n    newFunc.added = true;\n    this.target.functions.push(newFunc);\n\n    this.moveAliasFuncLast();\n\n    if (newFunc.params.length && newFunc.added ||\n        newFunc.def.params.length === 0) {\n      this.targetChanged();\n    }\n  }\n\n  removeFunction(func) {\n    this.target.functions = _.without(this.target.functions, func);\n    this.targetChanged();\n  }\n\n  moveFunction(func, offset) {\n    const index = this.target.functions.indexOf(func);\n    // @ts-ignore\n    _.move(this.target.functions, index, index + offset);\n    this.targetChanged();\n  }\n\n  moveAliasFuncLast() {\n    const aliasFunc = _.find(this.target.functions, func => {\n      return func.def.category === 'Alias';\n    });\n\n    if (aliasFunc) {\n      this.target.functions = _.without(this.target.functions, aliasFunc);\n      this.target.functions.push(aliasFunc);\n    }\n  }\n\n  toggleQueryOptions() {\n    this.showQueryOptions = !this.showQueryOptions;\n  }\n\n  onQueryOptionChange() {\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.onTargetBlur();\n  }\n\n  renderQueryOptionsText() {\n    const metricOptionsMap = {\n      showDisabledItems: \"Show disabled items\",\n      disableDataAlignment: \"Disable data alignment\",\n      useZabbixValueMapping: \"Use Zabbix value mapping\",\n    };\n\n    const problemsOptionsMap = {\n      sortProblems: \"Sort problems\",\n      acknowledged: \"Acknowledged\",\n      skipEmptyValues: \"Skip empty values\",\n      hostsInMaintenance: \"Show hosts in maintenance\",\n      limit: \"Limit problems\",\n      hostProxy: \"Show proxy\",\n      useTimeRange: \"Use time range\",\n    };\n\n    let optionsMap = {};\n\n    if (this.target.queryType === c.MODE_METRICS) {\n      optionsMap = metricOptionsMap;\n    } else if (this.target.queryType === c.MODE_PROBLEMS || this.target.queryType === c.MODE_TRIGGERS) {\n      optionsMap = problemsOptionsMap;\n    }\n\n    const options = [];\n    _.forOwn(this.target.options, (value, key) => {\n      if (value && optionsMap[key]) {\n        if (value === true) {\n          // Show only option name (if enabled) for boolean options\n          options.push(optionsMap[key]);\n        } else {\n          // Show \"option = value\" for another options\n          let optionValue = value;\n          if (value && value.text) {\n            optionValue = value.text;\n          } else if (value && value.value) {\n            optionValue = value.value;\n          }\n          options.push(optionsMap[key] + \" = \" + optionValue);\n        }\n      }\n    });\n    return \"Options: \" + options.join(', ');\n  }\n\n  /**\n   * Switch query editor to specified mode.\n   * Modes:\n   *  0 - items\n   *  1 - IT services\n   *  2 - Text metrics\n   */\n  switchEditorMode(mode) {\n    this.target.queryType = mode;\n    this.queryOptionsText = this.renderQueryOptionsText();\n    this.init();\n    this.targetChanged();\n  }\n}\n","import React, { PureComponent } from 'react';\nimport { parseLegacyVariableQuery } from '../utils';\nimport { SelectableValue } from '@grafana/data';\nimport { VariableQuery, VariableQueryTypes, VariableQueryProps, VariableQueryData } from '../types';\nimport { ZabbixInput } from './ZabbixInput';\nimport { InlineFormLabel, Select, Input } from '@grafana/ui';\n\nexport class ZabbixVariableQueryEditor extends PureComponent<VariableQueryProps, VariableQueryData> {\n  queryTypes: Array<SelectableValue<VariableQueryTypes>> = [\n    { value: VariableQueryTypes.Group, label: 'Group'},\n    { value: VariableQueryTypes.Host, label: 'Host' },\n    { value: VariableQueryTypes.Application, label: 'Application' },\n    { value: VariableQueryTypes.Item, label: 'Item' },\n    { value: VariableQueryTypes.ItemValues, label: 'Item values' },\n  ];\n\n  defaults: VariableQueryData = {\n    selectedQueryType: { value: VariableQueryTypes.Group, label: 'Group' },\n    queryType: VariableQueryTypes.Group,\n    group: '/.*/',\n    host: '',\n    application: '',\n    item: '',\n  };\n\n  constructor(props: VariableQueryProps) {\n    super(props);\n\n    if (this.props.query && typeof this.props.query === 'string') {\n      // Backward compatibility\n      const query = parseLegacyVariableQuery(this.props.query);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        selectedQueryType,\n        legacyQuery: this.props.query,\n        ...query\n      };\n    } else if (this.props.query) {\n      const query = (this.props.query as VariableQuery);\n      const selectedQueryType = this.getSelectedQueryType(query.queryType);\n      this.state = {\n        ...this.defaults,\n        ...query,\n        selectedQueryType,\n      };\n    } else {\n      this.state = this.defaults;\n    }\n  }\n\n  getSelectedQueryType(queryType: VariableQueryTypes) {\n    return this.queryTypes.find(q => q.value === queryType);\n  }\n\n  handleQueryUpdate = (evt: React.ChangeEvent<HTMLInputElement>, prop: string) => {\n    const value = evt.currentTarget.value;\n    this.setState((prevState: VariableQueryData) => {\n      const newQuery = {\n        ...prevState,\n      };\n      newQuery[prop] = value;\n\n      return {\n        ...newQuery,\n      };\n    });\n  }\n\n  handleQueryChange = () => {\n    const { queryType, group, host, application, item } = this.state;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  handleQueryTypeChange = (selectedItem: SelectableValue<VariableQueryTypes>) => {\n    this.setState({\n      ...this.state,\n      selectedQueryType: selectedItem,\n      queryType: selectedItem.value,\n    });\n\n    const { group, host, application, item } = this.state;\n    const queryType = selectedItem.value;\n    const queryModel = { queryType, group, host, application, item };\n    this.props.onChange(queryModel, `Zabbix - ${queryType}`);\n  }\n\n  render() {\n    const { selectedQueryType, legacyQuery, group, host, application, item } = this.state;\n\n    return (\n      <>\n        <div className=\"gf-form max-width-21\">\n          <InlineFormLabel width={10}>Query Type</InlineFormLabel>\n          <Select\n            width={11}\n            value={selectedQueryType}\n            options={this.queryTypes}\n            onChange={this.handleQueryTypeChange}\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <InlineFormLabel width={10}>Group</InlineFormLabel>\n            <ZabbixInput\n              value={group}\n              onChange={evt => this.handleQueryUpdate(evt, 'group')}\n              onBlur={this.handleQueryChange}\n            />\n          </div>\n          {selectedQueryType.value !== VariableQueryTypes.Group &&\n            <div className=\"gf-form max-width-30\">\n              <InlineFormLabel width={10}>Host</InlineFormLabel>\n              <ZabbixInput\n                value={host}\n                onChange={evt => this.handleQueryUpdate(evt, 'host')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n          }\n        </div>\n        {(selectedQueryType.value === VariableQueryTypes.Application ||\n          selectedQueryType.value === VariableQueryTypes.Item ||\n          selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-30\">\n              <InlineFormLabel width={10}>Application</InlineFormLabel>\n              <ZabbixInput\n                value={application}\n                onChange={evt => this.handleQueryUpdate(evt, 'application')}\n                onBlur={this.handleQueryChange}\n              />\n            </div>\n            {(selectedQueryType.value === VariableQueryTypes.Item ||\n              selectedQueryType.value === VariableQueryTypes.ItemValues) &&\n              <div className=\"gf-form max-width-30\">\n                <InlineFormLabel width={10}>Item</InlineFormLabel>\n                <ZabbixInput\n                  value={item}\n                  onChange={evt => this.handleQueryUpdate(evt, 'item')}\n                  onBlur={this.handleQueryChange}\n                />\n              </div>\n            }\n          </div>\n        }\n\n        {legacyQuery &&\n          <div className=\"gf-form\">\n            <InlineFormLabel width={10} tooltip=\"Original query string, read-only\">Legacy Query</InlineFormLabel>\n            <Input\n              value={legacyQuery}\n              readOnly={true}\n            />\n          </div>\n        }\n      </>\n    );\n  }\n}\n","import React, { useEffect, useState } from 'react';\nimport { getDataSourceSrv } from '@grafana/runtime';\nimport { DataSourcePluginOptionsEditorProps, DataSourceSettings, SelectableValue } from '@grafana/data';\nimport { DataSourceHttpSettings, LegacyForms, Field, Input, Button, InlineFormLabel, Select } from '@grafana/ui';\nconst { FormField, Switch } = LegacyForms;\nimport { ZabbixDSOptions, ZabbixSecureJSONData } from '../types';\n\nconst SUPPORTED_SQL_DS = ['mysql', 'postgres', 'influxdb'];\n\nexport type Props = DataSourcePluginOptionsEditorProps<ZabbixDSOptions, ZabbixSecureJSONData>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  const [selectedDBDatasource, setSelectedDBDatasource] = useState(null);\n  const [currentDSType, setCurrentDSType] = useState('');\n\n  // Apply some defaults on initial render\n  useEffect(() => {\n    const { jsonData, secureJsonFields } = options;\n\n    // Set secureJsonFields.password to password and then remove it from config\n    const { password, ...restJsonData } = jsonData;\n    if (!secureJsonFields?.password) {\n      if (!options.secureJsonData) {\n        options.secureJsonData = {};\n      }\n      options.secureJsonData.password = password;\n    }\n\n    onOptionsChange({\n      ...options,\n      jsonData: {\n        trends: true,\n        trendsFrom: '',\n        trendsRange: '',\n        cacheTTL: '',\n        timeout: '',\n        disableDataAlignment: false,\n        ...restJsonData,\n      },\n    });\n\n    if (options.jsonData.dbConnectionEnable) {\n      if (!options.jsonData.dbConnectionDatasourceId) {\n        const dsName = options.jsonData.dbConnectionDatasourceName;\n        getDataSourceSrv().get(dsName)\n        .then(ds => {\n          if (ds) {\n            const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === ds.id);\n            setSelectedDBDatasource({ label: selectedDs.name, value: selectedDs.id });\n            setCurrentDSType(selectedDs.type);\n            onOptionsChange({\n              ...options,\n              jsonData: {\n                ...options.jsonData,\n                dbConnectionDatasourceId: ds.id,\n              },\n            });\n          }\n        });\n      } else {\n        const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === options.jsonData.dbConnectionDatasourceId);\n        setSelectedDBDatasource({ label: selectedDs.name, value: selectedDs.id });\n        setCurrentDSType(selectedDs.type);\n      }\n    }\n  }, []);\n\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost/zabbix/api_jsonrpc.php'}\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Zabbix API details</h3>\n        <div className=\"gf-form max-width-25\">\n          <FormField\n            labelWidth={7}\n            inputWidth={15}\n            label=\"Username\"\n            value={options.jsonData.username || ''}\n            onChange={jsonDataChangeHandler('username', options, onOptionsChange)}\n            required\n          />\n        </div>\n        <div className=\"gf-form max-width-25\">\n          {options.secureJsonFields?.password ?\n            <>\n              <FormField\n                labelWidth={7}\n                inputWidth={15}\n                label=\"Password\"\n                disabled={true}\n                value=\"\"\n                placeholder=\"Configured\"\n              />\n              <Button onClick={resetSecureJsonField('password', options, onOptionsChange)}>Reset</Button>\n            </>:\n            <FormField\n              labelWidth={7}\n              inputWidth={15}\n              label=\"Password\"\n              type=\"password\"\n              value={options.secureJsonData?.password || options.jsonData.password || ''}\n              onChange={secureJsonDataChangeHandler('password', options, onOptionsChange)}\n              required\n            />\n          }\n        </div>\n        <Switch\n          label=\"Trends\"\n          labelClass=\"width-7\"\n          checked={options.jsonData.trends}\n          onChange={jsonDataSwitchHandler('trends', options, onOptionsChange)}\n        />\n        {options.jsonData.trends &&\n          <>\n            <div className=\"gf-form\">\n              <FormField\n                labelWidth={7}\n                inputWidth={4}\n                label=\"After\"\n                value={options.jsonData.trendsFrom || ''}\n                placeholder=\"7d\"\n                onChange={jsonDataChangeHandler('trendsFrom', options, onOptionsChange)}\n                tooltip=\"Time after which trends will be used.\n                  Best practice is to set this value to your history storage period (7d, 30d, etc).\"\n              />\n            </div>\n            <div className=\"gf-form\">\n              <FormField\n                labelWidth={7}\n                inputWidth={4}\n                label=\"Range\"\n                value={options.jsonData.trendsRange || ''}\n                placeholder=\"4d\"\n                onChange={jsonDataChangeHandler('trendsRange', options, onOptionsChange)}\n                tooltip=\"Time range width after which trends will be used instead of history.\n                  It's better to set this value in range of 4 to 7 days to prevent loading large amount of history data.\"\n              />\n            </div>\n          </>\n        }\n        <div className=\"gf-form\">\n          <FormField\n            labelWidth={7}\n            inputWidth={4}\n            label=\"Cache TTL\"\n            value={options.jsonData.cacheTTL || ''}\n            placeholder=\"1h\"\n            onChange={jsonDataChangeHandler('cacheTTL', options, onOptionsChange)}\n            tooltip=\"Zabbix data source caches metric names in memory. Specify how often data will be updated.\"\n          />\n        </div>\n        <div className=\"gf-form\">\n          <FormField\n            labelWidth={7}\n            inputWidth={4}\n            label=\"Timeout\"\n            value={options.jsonData.timeout || ''}\n            placeholder=\"30\"\n            onChange={jsonDataChangeHandler('timeout', options, onOptionsChange)}\n            tooltip=\"Zabbix API connection timeout in seconds. Default is 30.\"\n          />\n        </div>\n      </div>\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Direct DB Connection</h3>\n        <Switch\n          label=\"Enable\"\n          labelClass=\"width-9\"\n          checked={options.jsonData.dbConnectionEnable}\n          onChange={jsonDataSwitchHandler('dbConnectionEnable', options, onOptionsChange)}\n        />\n        {options.jsonData.dbConnectionEnable &&\n          <>\n            <div className=\"gf-form\">\n              <InlineFormLabel width={9}>Data Source</InlineFormLabel>\n              <Select\n                width={32}\n                options={getDirectDBDSOptions()}\n                value={selectedDBDatasource}\n                onChange={directDBDatasourceChanegeHandler(options, onOptionsChange, setSelectedDBDatasource, setCurrentDSType)}\n              />\n            </div>\n            {currentDSType === 'influxdb' &&\n              <div className=\"gf-form\">\n                <FormField\n                  labelWidth={9}\n                  inputWidth={16}\n                  label=\"Retention Policy\"\n                  value={options.jsonData.dbConnectionRetentionPolicy || ''}\n                  placeholder=\"Retention policy name\"\n                  onChange={jsonDataChangeHandler('dbConnectionRetentionPolicy', options, onOptionsChange)}\n                  tooltip=\"Specify retention policy name for fetching long-term stored data (optional).\n                    Leave it blank if only default retention policy used.\"\n                />\n              </div>\n            }\n          </>\n        }\n      </div>\n\n      <div className=\"gf-form-group\">\n        <h3 className=\"page-heading\">Other</h3>\n        <Switch\n          label=\"Disable acknowledges for read-only users\"\n          labelClass=\"width-16\"\n          checked={options.jsonData.disableReadOnlyUsersAck}\n          onChange={jsonDataSwitchHandler('disableReadOnlyUsersAck', options, onOptionsChange)}\n        />\n        <Switch\n          label=\"Disable data alignment\"\n          labelClass=\"width-16\"\n          checked={!!options.jsonData.disableDataAlignment}\n          onChange={jsonDataSwitchHandler('disableDataAlignment', options, onOptionsChange)}\n          tooltip=\"Data alignment feature aligns points based on item update interval.\n            For instance, if value collected once per minute, then timestamp of the each point will be set to the start of corresponding minute.\n            This alignment required for proper work of the stacked graphs.\n            If you don't need stacked graphs and want to get exactly the same timestamps as in Zabbix, then you can disable this feature.\"\n        />\n      </div>\n    </>\n  );\n};\n\nconst jsonDataChangeHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst jsonDataSwitchHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement>\n) => {\n  onChange({\n    ...value,\n    jsonData: {\n      ...value.jsonData,\n      [key]: (event.target as HTMLInputElement).checked,\n    },\n  });\n};\n\nconst secureJsonDataChangeHandler = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>\n) => {\n  onChange({\n    ...value,\n    secureJsonData: {\n      ...value.secureJsonData,\n      [key]: event.currentTarget.value,\n    },\n  });\n};\n\nconst resetSecureJsonField = (\n  key: keyof ZabbixDSOptions,\n  value: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange']\n) => (\n  event: React.SyntheticEvent<HTMLButtonElement>\n) => {\n  onChange({\n    ...value,\n    secureJsonFields: {\n      ...value.secureJsonFields,\n      [key]: false,\n    },\n  });\n};\n\nconst directDBDatasourceChanegeHandler = (\n  options: DataSourceSettings<ZabbixDSOptions, ZabbixSecureJSONData>,\n  onChange: Props['onOptionsChange'],\n  setSelectedDS: React.Dispatch<any>,\n  setSelectedDSType: React.Dispatch<any>,\n) => (\n  value: SelectableValue<number>\n) => {\n  const selectedDs = getDirectDBDatasources().find(dsOption => dsOption.id === value.value);\n  setSelectedDS({ label: selectedDs.name, value: selectedDs.id });\n  setSelectedDSType(selectedDs.type);\n  onChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      dbConnectionDatasourceId: value.value\n    },\n  });\n};\n\nconst getDirectDBDatasources = () => {\n  let dsList = (getDataSourceSrv() as any).getAll();\n  dsList = dsList.filter(ds => SUPPORTED_SQL_DS.includes(ds.type));\n  return dsList;\n};\n\nconst getDirectDBDSOptions = () => {\n  const dsList = getDirectDBDatasources();\n  const dsOpts: Array<SelectableValue<number>> = dsList.map(ds => ({ label: ds.name, value: ds.id, description: ds.type }));\n  return dsOpts;\n};\n","import angular from 'angular';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport * as metricFunctions from './metricFunctions';\n\nangular\n  .module('grafana.directives')\n  .directive('addMetricFunction',\n\n  /** @ngInject */\n  function($compile) {\n    var inputTemplate = '<input type=\"text\"'+\n                          ' class=\"gf-form-input\"' +\n                          ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n    var buttonTemplate = '<a  class=\"gf-form-label tight-form-func dropdown-toggle query-part\"' +\n                            ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n                            '<i class=\"fa fa-plus\"></i></a>';\n\n    return {\n      link: function($scope, elem) {\n        var categories = metricFunctions.getCategories();\n        var allFunctions = getAllFunctionNames(categories);\n\n        $scope.functionMenu = createFunctionDropDownMenu(categories);\n\n        var $input = $(inputTemplate);\n        var $button = $(buttonTemplate);\n        $input.appendTo(elem);\n        $button.appendTo(elem);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: function (value) {\n            var funcDef = metricFunctions.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, function(funcName) {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) { return; }\n            }\n\n            $scope.$apply(function() {\n              $scope.ctrl.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          }\n        });\n\n        $button.click(function() {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(function() {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(function() {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(function() {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      }\n    };\n  });\n\nfunction getAllFunctionNames(categories) {\n  return _.reduce(categories, function(list, category) {\n    _.each(category, function(func) {\n      list.push(func.name);\n    });\n    return list;\n  }, []);\n}\n\nfunction createFunctionDropDownMenu(categories) {\n  return _.map(categories, function(list, category) {\n    return {\n      text: category,\n      submenu: _.map(list, function(value) {\n        return {\n          text: value.name,\n          click: \"ctrl.addFunction('\" + value.name + \"')\",\n        };\n      })\n    };\n  });\n}\n\n","import coreModule from 'grafana/app/core/core_module';\n\nexport function react2AngularDirective(name: string, component: any, options: any) {\n  coreModule.directive(name, [\n    'reactDirective',\n    reactDirective => {\n      return reactDirective(component, options);\n    },\n  ]);\n}\n","import React from 'react';\n\nconst DOCS_FUNC_REF_URL = 'https://alexanderzobnin.github.io/grafana-zabbix/reference/functions/';\n\nexport interface FunctionDescriptor {\n  text: string;\n  params: string[];\n  def: {\n    category: string;\n    defaultParams: string[];\n    description?: string;\n    fake: boolean;\n    name: string;\n    params: string[];\n  };\n}\n\nexport interface FunctionEditorControlsProps {\n  onMoveLeft: (func: FunctionDescriptor) => void;\n  onMoveRight: (func: FunctionDescriptor) => void;\n  onRemove: (func: FunctionDescriptor) => void;\n}\n\nconst FunctionHelpButton = (props: { description: string; name: string; onDescriptionShow: () => void }) => {\n  if (props.description) {\n    return <span className=\"pointer fa fa-question-circle\" onClick={props.onDescriptionShow} />;\n  }\n\n  return (\n    <span\n      className=\"pointer fa fa-question-circle\"\n      onClick={() => {\n        window.open(\n          DOCS_FUNC_REF_URL + '#' + props.name,\n          '_blank'\n        );\n      }}\n    />\n  );\n};\n\nexport const FunctionEditorControls = (\n  props: FunctionEditorControlsProps & {\n    func: FunctionDescriptor;\n    onDescriptionShow: () => void;\n  }\n) => {\n  const { func, onMoveLeft, onMoveRight, onRemove, onDescriptionShow } = props;\n  return (\n    <div\n      style={{\n        display: 'flex',\n        width: '60px',\n        justifyContent: 'space-between',\n      }}\n    >\n      <span className=\"pointer fa fa-arrow-left\" onClick={() => onMoveLeft(func)} />\n      <FunctionHelpButton\n        name={func.def.name}\n        description={func.def.description}\n        onDescriptionShow={onDescriptionShow}\n      />\n      <span className=\"pointer fa fa-remove\" onClick={() => onRemove(func)} />\n      <span className=\"pointer fa fa-arrow-right\" onClick={() => onMoveRight(func)} />\n    </div>\n  );\n};\n","import React from 'react';\n// import rst2html from 'rst2html';\nimport { FunctionDescriptor, FunctionEditorControlsProps, FunctionEditorControls } from './FunctionEditorControls';\n\n// @ts-ignore\nimport { PopoverController, Popover } from '@grafana/ui';\n\ninterface FunctionEditorProps extends FunctionEditorControlsProps {\n  func: FunctionDescriptor;\n}\n\ninterface FunctionEditorState {\n  showingDescription: boolean;\n}\n\nclass FunctionEditor extends React.PureComponent<FunctionEditorProps, FunctionEditorState> {\n  private triggerRef = React.createRef<HTMLSpanElement>();\n\n  constructor(props: FunctionEditorProps) {\n    super(props);\n\n    this.state = {\n      showingDescription: false,\n    };\n  }\n\n  renderContent = ({ updatePopperPosition }) => {\n    const {\n      onMoveLeft,\n      onMoveRight,\n      func: {\n        def: { name, description },\n      },\n    } = this.props;\n    const { showingDescription } = this.state;\n\n    if (showingDescription) {\n      return (\n        <div style={{ overflow: 'auto', maxHeight: '30rem', textAlign: 'left', fontWeight: 'normal' }}>\n          <h4 style={{ color: 'white' }}> {name} </h4>\n          <div>{description}</div>\n        </div>\n      );\n    }\n\n    return (\n      <FunctionEditorControls\n        {...this.props}\n        onMoveLeft={() => {\n          onMoveLeft(this.props.func);\n          updatePopperPosition();\n        }}\n        onMoveRight={() => {\n          onMoveRight(this.props.func);\n          updatePopperPosition();\n        }}\n        onDescriptionShow={() => {\n          this.setState({ showingDescription: true }, () => {\n            updatePopperPosition();\n          });\n        }}\n      />\n    );\n  };\n\n  render() {\n    return (\n      <PopoverController content={this.renderContent} placement=\"top\" hideAfter={300}>\n        {(showPopper, hidePopper, popperProps) => {\n          return (\n            <>\n              {this.triggerRef && (\n                <Popover\n                  {...popperProps}\n                  referenceElement={this.triggerRef.current}\n                  wrapperClassName=\"popper\"\n                  className=\"popper__background\"\n                  onMouseLeave={() => {\n                    this.setState({ showingDescription: false });\n                    hidePopper();\n                  }}\n                  onMouseEnter={showPopper}\n                  renderArrow={({ arrowProps, placement }) => (\n                    <div className=\"popper__arrow\" data-placement={placement} {...arrowProps} />\n                  )}\n                />\n              )}\n\n              <span\n                ref={this.triggerRef}\n                onClick={popperProps.show ? hidePopper : showPopper}\n                onMouseLeave={() => {\n                  hidePopper();\n                  this.setState({ showingDescription: false });\n                }}\n                style={{ cursor: 'pointer' }}\n              >\n                {this.props.func.def.name}\n              </span>\n            </>\n          );\n        }}\n      </PopoverController>\n    );\n  }\n}\n\nexport { FunctionEditor };\n","import coreModule from 'grafana/app/core/core_module';\nimport _ from 'lodash';\nimport $ from 'jquery';\nimport { react2AngularDirective } from './react2angular';\nimport { FunctionEditor } from './components/FunctionEditor';\n\n/** @ngInject */\nexport function zabbixFunctionEditor($compile, templateSrv) {\n  const funcSpanTemplate = `\n    <zbx-function-editor\n      func=\"func\"\n      onRemove=\"ctrl.handleRemoveFunction\"\n      onMoveLeft=\"ctrl.handleMoveLeft\"\n      onMoveRight=\"ctrl.handleMoveRight\">\n    </zbx-function-editor>\n    <span>(</span>\n  `;\n  const paramTemplate =\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\n\n  return {\n    restrict: 'A',\n    link: function postLink($scope, elem) {\n      const $funcLink = $(funcSpanTemplate);\n      const ctrl = $scope.ctrl;\n      const func = $scope.func;\n      let scheduledRelink = false;\n      let paramCountAtLink = 0;\n      let cancelBlur = null;\n\n      ctrl.handleRemoveFunction = func => {\n        ctrl.removeFunction(func);\n      };\n\n      ctrl.handleMoveLeft = func => {\n        ctrl.moveFunction(func, -1);\n      };\n\n      ctrl.handleMoveRight = func => {\n        ctrl.moveFunction(func, 1);\n      };\n\n      function clickFuncParam(this: any, paramIndex) {\n        /*jshint validthis:true */\n\n        const $link = $(this);\n        const $comma = $link.prev('.comma');\n        const $input = $link.next();\n\n        $input.val(func.params[paramIndex]);\n\n        $comma.removeClass('query-part__last');\n        $link.hide();\n        $input.show();\n        $input.focus();\n        $input.select();\n\n        const typeahead = $input.data('typeahead');\n        if (typeahead) {\n          $input.val('');\n          typeahead.lookup();\n        }\n      }\n\n      function scheduledRelinkIfNeeded() {\n        if (paramCountAtLink === func.params.length) {\n          return;\n        }\n\n        if (!scheduledRelink) {\n          scheduledRelink = true;\n          setTimeout(() => {\n            relink();\n            scheduledRelink = false;\n          }, 200);\n        }\n      }\n\n      function paramDef(index) {\n        if (index < func.def.params.length) {\n          return func.def.params[index];\n        }\n        if ((_.last(func.def.params) as any).multiple) {\n          return _.assign({}, _.last(func.def.params), { optional: true });\n        }\n        return {};\n      }\n\n      function switchToLink(inputElem, paramIndex) {\n        /*jshint validthis:true */\n        const $input = $(inputElem);\n\n        clearTimeout(cancelBlur);\n        cancelBlur = null;\n\n        const $link = $input.prev();\n        const $comma = $link.prev('.comma');\n        const newValue = $input.val();\n\n        // remove optional empty params\n        if (newValue !== '' || paramDef(paramIndex).optional) {\n          func.updateParam(newValue, paramIndex);\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\n        }\n\n        scheduledRelinkIfNeeded();\n\n        $scope.$apply(() => {\n          ctrl.targetChanged();\n        });\n\n        if ($link.hasClass('query-part__last') && newValue === '') {\n          $comma.addClass('query-part__last');\n        } else {\n          $link.removeClass('query-part__last');\n        }\n\n        $input.hide();\n        $link.show();\n      }\n\n      // this = input element\n      function inputBlur(this: any, paramIndex) {\n        /*jshint validthis:true */\n        const inputElem = this;\n        // happens long before the click event on the typeahead options\n        // need to have long delay because the blur\n        cancelBlur = setTimeout(() => {\n          switchToLink(inputElem, paramIndex);\n        }, 200);\n      }\n\n      function inputKeyPress(this: any, paramIndex, e) {\n        /*jshint validthis:true */\n        if (e.which === 13) {\n          $(this).blur();\n        }\n      }\n\n      function inputKeyDown(this: any) {\n        /*jshint validthis:true */\n        this.style.width = (3 + this.value.length) * 8 + 'px';\n      }\n\n      function addTypeahead($input, paramIndex) {\n        $input.attr('data-provide', 'typeahead');\n\n        let options = paramDef(paramIndex).options;\n        if (paramDef(paramIndex).type === 'int' || paramDef(paramIndex).type === 'float') {\n          options = _.map(options, val => {\n            return val.toString();\n          });\n        }\n\n        $input.typeahead({\n          source: options,\n          minLength: 0,\n          items: 20,\n          updater: value => {\n            $input.val(value);\n            switchToLink($input[0], paramIndex);\n            return value;\n          },\n        });\n\n        const typeahead = $input.data('typeahead');\n        typeahead.lookup = function() {\n          this.query = this.$element.val() || '';\n          return this.process(this.source);\n        };\n      }\n\n      function addElementsAndCompile() {\n        $funcLink.appendTo(elem);\n\n        const defParams: any = _.clone(func.def.params);\n        const lastParam: any = _.last(func.def.params);\n\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\n          defParams.push(_.assign({}, lastParam, { optional: true }));\n        }\n\n        _.each(defParams, (param: any, index: number) => {\n          if (param.optional && func.params.length < index) {\n            return false;\n          }\n\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n          const hasValue = paramValue !== null && paramValue !== undefined;\n\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\n          if (last && param.multiple) {\n            paramValue = '+';\n          }\n\n          if (index > 0) {\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">,&nbsp; </span>').appendTo(elem);\n          }\n\n          const $paramLink = $(\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\n              (last ? ' query-part__last' : '') +\n              '\">' +\n              (hasValue ? paramValue : '&nbsp;') +\n              '</a>'\n          );\n          const $input = $(paramTemplate);\n          $input.attr('placeholder', param.name);\n\n          paramCountAtLink++;\n\n          $paramLink.appendTo(elem);\n          $input.appendTo(elem);\n\n          $input.blur(_.partial(inputBlur, index));\n          $input.keyup(inputKeyDown);\n          $input.keypress(_.partial(inputKeyPress, index));\n          $paramLink.click(_.partial(clickFuncParam, index));\n\n          if (param.options) {\n            addTypeahead($input, index);\n          }\n\n          return true;\n        });\n\n        $('<span>)</span>').appendTo(elem);\n\n        $compile(elem.contents())($scope);\n      }\n\n      function ifJustAddedFocusFirstParam() {\n        if ($scope.func.added) {\n          $scope.func.added = false;\n          setTimeout(() => {\n            elem\n              .find('.graphite-func-param-link')\n              .first()\n              .click();\n          }, 10);\n        }\n      }\n\n      function relink() {\n        elem.children().remove();\n        addElementsAndCompile();\n        ifJustAddedFocusFirstParam();\n      }\n\n      relink();\n    },\n  };\n}\n\ncoreModule.directive('zabbixFunctionEditor', zabbixFunctionEditor);\n\nreact2AngularDirective('zbxFunctionEditor', FunctionEditor, ['func', 'onRemove', 'onMoveLeft', 'onMoveRight']);\n","import { DataSourcePlugin } from '@grafana/data';\nimport { loadPluginCss } from '@grafana/runtime';\nimport { ZabbixDatasource } from './datasource';\nimport { ZabbixQueryController } from './query.controller';\nimport { ZabbixVariableQueryEditor } from './components/VariableQueryEditor';\nimport { ConfigEditor } from './components/ConfigEditor';\nimport './add-metric-function.directive';\nimport './metric-function-editor.directive';\n\nclass ZabbixAnnotationsQueryController {\n  static templateUrl = 'datasource-zabbix/partials/annotations.editor.html';\n}\n\nZabbixQueryController.templateUrl = 'datasource-zabbix/partials/query.editor.html';\n\nloadPluginCss({\n  dark: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.dark.css',\n  light: 'plugins/alexanderzobnin-zabbix-app/css/grafana-zabbix.light.css'\n});\n\nexport const plugin = new DataSourcePlugin(ZabbixDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(ZabbixQueryController)\n  .setAnnotationQueryCtrl(ZabbixAnnotationsQueryController)\n  .setVariableQueryEditor(ZabbixVariableQueryEditor);\n"],"sourceRoot":""}